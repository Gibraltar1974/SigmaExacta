<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Capability Index Calculator | Sigma Exacta</title>
    <meta name="description"
        content="Calculate Cp, Cpk, Pp & Ppk with our free Capability Index tool. This advanced calculator includes normality tests, distribution plots, and I-Charts for robust analysis.">
    <meta name="keywords"
        content="Open source, Free software, SigmaExacta, capability index calculator, cpk calculator, process capability, normality check, cp, cpk, cpm, pp, ppk, six sigma, spc tool, control chart, i-chart, lsl, usl, normal distribution plot, normality tests, Shapiro-Wilk, Anderson-Darling, Kolmogorov-Smirnov">

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"
        integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="icon" href="sigma-exacta-icon.jpg" type="image/jpeg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;800&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="styles.css">
    <link rel="canonical" href="https://sigmaexacta.com/cpk_calculator">

    <style>
        /* Estilos de la Página de la Calculadora */
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --light-color: #ecf0f1;
            --dark-color: #2c3e50;
            font-size: 16px;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background-color: #f4f7f9;
            color: #333;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            width: 100vw;
            max-width: 100vw;
        }

        .main-content-wrapper {
            max-width: 100%;
            margin: 0 auto;
            padding: 1.25rem;
            width: 100%;
            box-sizing: border-box;
        }

        .main-header {
            text-align: center;
            padding: 1rem 0;
            margin-bottom: 1rem;
            border-bottom: 1px solid #ddd;
        }

        .main-header h1 {
            color: var(--primary-color);
            font-size: clamp(1.5rem, 4vw, 1.8rem);
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
            font-weight: 800;
        }

        .main-header p {
            color: #7f8c8d;
            font-weight: 400;
            font-size: 1.1rem;
            max-width: 800px;
            margin: 0 auto;
        }

        /* ===== BOTONES DE ACCIÓN GLOBAL ===== */
        .global-actions {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin: 1.5rem 0 2rem 0;
            flex-wrap: wrap;
        }

        .global-btn {
            padding: 0.8rem 1.5rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-family: 'Nunito', sans-serif;
            font-size: 1rem;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.3s ease;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
        }

        .global-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.15);
        }

        /* ESTILOS COMO EN KANO.HTML */
        .global-btn.secondary {
            background-color: #2ecc71;
            color: white;
        }

        .global-btn.secondary:hover {
            background-color: #27ad60;
        }

        .global-btn.danger {
            background-color: #c0392b;
            color: white;
        }

        .global-btn.danger:hover {
            background-color: #a5281c;
        }

        /* ===== ESTILOS DEL SISTEMA DE PESTAÑAS (WIZARD) ===== */
        .tabs-nav {
            display: flex;
            background-color: #f1f5f9;
            border-radius: 8px 8px 0 0;
            overflow-x: auto;
            border-bottom: 2px solid var(--secondary-color);
            margin-bottom: 0;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .tabs-nav::-webkit-scrollbar {
            display: none;
        }

        .tab-btn {
            padding: 1rem 1.5rem;
            border: none;
            background: none;
            cursor: pointer;
            font-weight: 700;
            color: #64748b;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
            font-family: 'Nunito', sans-serif;
            font-size: 1rem;
        }

        @media (min-width: 992px) {
            .tabs-nav {
                overflow-x: hidden;
            }

            .tab-btn {
                flex: 1;
                justify-content: center;
                padding: 1rem 0.5rem;
            }
        }

        .tab-btn:hover {
            background-color: #e2e8f0;
            color: var(--primary-color);
        }

        .tab-btn.active {
            background-color: #fff;
            color: var(--secondary-color);
            border-bottom-color: var(--secondary-color);
            border-radius: 8px 8px 0 0;
            margin-bottom: -2px;
            border-left: 1px solid #e1e5e9;
            border-right: 1px solid #e1e5e9;
            border-top: 1px solid #e1e5e9;
        }

        /* CONTENEDOR PRINCIPAL DE TABS - FONDO BLANCO */
        .tabs-container {
            background: #fff;
            border: 1px solid #e1e5e9;
            border-top: none;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            width: 100%;
            max-width: 100%;
            overflow-x: hidden;
            position: relative;
            margin-bottom: 2rem;
        }

        /* PESTAÑAS - Todas con el mismo ancho */
        .wizard-tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
            width: 100%;
            box-sizing: border-box;
            max-width: 100%;
        }

        .wizard-tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(5px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* CONTENIDO DE TODAS LAS TABS - Mismo padding */
        .tab-content-wrapper {
            padding: 2rem;
            width: 100%;
            box-sizing: border-box;
            max-width: 100%;
        }

        /* Ajuste para pantallas móviles */
        @media (max-width: 768px) {
            .main-content-wrapper {
                padding: 0.75rem;
            }

            .tabs-container {
                margin: 0 -0.75rem;
                width: calc(100% + 1.5rem);
                border-radius: 0;
                border-left: none;
                border-right: none;
            }

            .tab-content-wrapper {
                padding: 1rem;
            }

            .global-actions {
                flex-direction: column;
                align-items: stretch;
            }

            .global-btn {
                width: 100%;
                justify-content: center;
            }
        }

        @media (max-width: 480px) {
            .main-content-wrapper {
                padding: 0.5rem;
            }

            .tabs-container {
                margin: 0 -0.5rem;
                width: calc(100% + 1rem);
            }

            .tab-content-wrapper {
                padding: 0.75rem;
            }
        }

        .tab-nav-buttons {
            display: flex;
            justify-content: flex-end;
            margin-top: 2rem;
            padding-top: 1rem;
            border-top: 1px solid #eee;
            width: 100%;
        }

        .btn-next-tab {
            background-color: var(--secondary-color);
            color: white;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.7rem 1.25rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            font-family: 'Nunito', sans-serif;
            transition: background-color 0.3s, transform 0.2s;
        }

        .btn-next-tab:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
        }

        /* ===== ESTILOS ORIGINALES MODIFICADOS ===== */

        .container {
            background-color: white;
            border-radius: 8px;
            padding: 1.5rem;
            margin-top: 1.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 100%;
            box-sizing: border-box;
            max-width: 100%;
        }

        .container:first-child {
            margin-top: 0;
        }

        .container h2 {
            color: var(--primary-color);
            margin-top: 0;
            border-bottom: 2px solid var(--secondary-color);
            padding-bottom: 0.6rem;
            font-weight: 800;
        }

        .container p,
        .container ol,
        .container ul,
        .legend {
            line-height: 1.8;
        }

        .container ol,
        .container ul {
            padding-left: 1.25rem;
        }

        .formula-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            text-align: center;
            margin-top: 1.5rem;
        }

        .formula-item {
            padding: 1.5rem 1rem;
            border: 1px solid #eee;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 120px;
            font-size: 1.1em;
            width: 100%;
            box-sizing: border-box;
            overflow: hidden;
        }

        .formula-item>div {
            width: 100%;
            overflow-x: auto;
            text-align: center;
            padding: 0.5rem 0;
        }

        .formula-item h3 {
            margin-top: 0;
            margin-bottom: 1rem;
            color: var(--primary-color);
            width: 100%;
            text-align: center;
        }

        .legend {
            margin-top: 2rem;
            padding: 1rem;
            border: 1px solid #eee;
            border-radius: 8px;
            background-color: #fdfdfd;
        }

        .legend h3 {
            margin-top: 0;
            color: var(--primary-color);
        }

        .legend ul {
            list-style: none;
            padding: 0;
        }

        .legend li {
            margin-bottom: 0.5rem;
        }

        .legend code {
            background-color: #eee;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
        }

        .calculator-section {
            margin-top: 0;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }

        .calculation-block {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.25rem;
            background-color: white;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            width: 100%;
            box-sizing: border-box;
            max-width: 100%;
        }

        @media (max-width: 768px) {

            .container,
            .calculation-block {
                border-radius: 0;
                margin-top: 1rem;
                box-shadow: none;
                border-left: none;
                border-right: none;
            }
        }

        .calculation-title {
            font-weight: 800;
            font-size: 1.2em;
            margin-bottom: 1rem;
            color: var(--primary-color);
            border-bottom: 1px solid #eee;
            padding-bottom: 0.6rem;
        }

        label {
            display: block;
            margin-bottom: 0.6rem;
            color: var(--primary-color);
            font-weight: 600;
        }

        input[type="text"],
        textarea {
            width: 100%;
            padding: 0.6rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
            margin-bottom: 1rem;
            box-sizing: border-box;
            transition: border 0.3s, box-shadow 0.3s;
            font-family: 'Nunito', sans-serif;
            max-width: 100%;
        }

        textarea {
            resize: vertical;
            min-height: 80px;
        }

        button {
            background-color: var(--secondary-color);
            color: white;
            padding: 0.7rem 1.25rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
            font-size: 1rem;
            transition: background-color 0.3s, box-shadow 0.3s;
            font-weight: 600;
            font-family: 'Nunito', sans-serif;
        }

        .button-yellow {
            background-color: #f39c12;
        }

        .button-yellow:hover {
            background-color: #e67e22;
        }

        .button-green {
            background-color: #27ae60;
        }

        .button-green:hover {
            background-color: #229954;
        }

        .reset-btn {
            background-color: #e74c3c;
        }

        .reset-btn:hover {
            background-color: #c0392b;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-left: -5px;
            margin-top: 10px;
        }

        /* ESTILOS PARA MOSTRAR RESULTADOS DE DIFERENTES DATASETS */
        .results-container {
            display: flex;
            flex-wrap: wrap;
            gap: 1.25rem;
            align-items: stretch;
            margin-top: 1.25rem;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }

        .dataset-results-wrapper {
            display: none;
            width: 100%;
            flex-wrap: wrap;
            gap: 1.25rem;
            max-width: 100%;
        }

        .dataset-results-wrapper.active {
            display: flex;
        }

        .charts-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
            min-width: 300px;
            max-width: 100%;
            width: 100%;
            box-sizing: border-box;
        }

        .charts-wrapper>div {
            height: 480px;
            width: 100%;
            position: relative;
        }

        .chart-canvas {
            max-width: 100% !important;
            width: 100% !important;
            height: auto !important;
        }

        .cpk-chart-container,
        .overall-chart-container,
        .control-chart-container,
        .overall-control-chart-container,
        .qq-chart-container {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 1rem;
            min-width: 300px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        /* MARCA DE AGUA EN CADA GRÁFICO - CORREGIDO */
        .chart-watermark {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 60px;
            height: auto;
            filter: invert(1);
            opacity: 0.15;
            pointer-events: none;
            z-index: 10;
        }

        .results-box {
            background: white;
            padding: 1.25rem;
            border-radius: 8px;
            border: 1px solid #ddd;
            width: 350px;
            min-width: 300px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
        }

        .results-content {
            flex-grow: 1;
        }

        .results-box p {
            margin: 0.5rem 0;
            color: var(--primary-color);
        }

        .result-value {
            font-weight: bold;
            color: var(--dark-color);
        }

        .normality-results {
            border-top: 1px solid #eee;
            margin-top: 1rem;
            padding-top: 0.5rem;
        }

        .normality-results p {
            font-size: 0.9em;
        }

        .pass {
            color: #27ae60;
            font-weight: bold;
        }

        .fail {
            color: #e74c3c;
            font-weight: bold;
        }

        .dataset-container {
            margin-bottom: 1rem;
            position: relative;
        }

        .dataset-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .dataset-title {
            font-weight: 600;
            color: var(--primary-color);
        }

        .remove-dataset-btn {
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.3rem 0.6rem;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.3s;
        }

        .remove-dataset-btn:hover {
            background-color: #c0392b;
        }

        .datasets-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 1rem;
        }

        /* PESTAÑAS DE DATASETS Y OVERALL - MODIFICADO */
        .dataset-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 1rem;
            margin-top: 1rem;
            width: 100%;
        }

        .dataset-tab {
            padding: 0.5rem 1rem;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            white-space: nowrap;
            color: #333;
        }

        .dataset-tab:hover {
            background-color: #e2e8f0;
        }

        .dataset-tab.active {
            background-color: var(--secondary-color);
            color: white;
            border-color: var(--secondary-color);
        }

        /* BOTÓN OVERALL - GRIS POR DEFECTO, VERDE AL ACTIVAR */
        .dataset-tab.overall-tab {
            background-color: #f0f0f0;
            /* Gris por defecto */
            color: #333;
            border-color: #ddd;
        }

        .dataset-tab.overall-tab:hover {
            background-color: #e2e8f0;
        }

        .dataset-tab.overall-tab.active {
            background-color: #27ae60;
            /* Verde cuando está activo */
            color: white;
            border-color: #27ae60;
        }

        .dataset-tab.overall-tab.active:hover {
            background-color: #229954;
        }

        .anderson-formula {
            font-size: 1rem !important;
            overflow-x: auto;
            white-space: nowrap;
            padding: 1rem;
            padding-bottom: 0.5rem;
            max-width: 100%;
            box-sizing: border-box;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
        }

        .chart-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
            padding: 10px 0 0 0;
        }

        .legend-item {
            display: flex;
            align-items: center;
            font-size: 0.85rem;
        }

        .legend-color {
            width: 20px;
            height: 3px;
            margin-right: 5px;
        }

        .disclaimer-note {
            margin-top: 2rem;
            padding: 0 1rem;
            font-size: .8rem;
            color: #777;
            max-width: 100%;
            margin-left: auto;
            margin-right: auto;
            line-height: 1.6;
        }

        .overall-results-container {
            display: flex;
            flex-wrap: wrap;
            gap: 1.25rem;
            align-items: stretch;
            margin-top: 1.25rem;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }

        /* CONTENEDOR PARA RESULTADOS OVERALL */
        #overall-results-wrapper {
            display: none;
            width: 100%;
            flex-wrap: wrap;
            gap: 1.25rem;
        }

        #overall-results-wrapper.active {
            display: flex;
        }

        /* Estilos para fórmulas KaTeX */
        .katex {
            font-size: 1.1em !important;
        }

        .katex-display {
            margin: 0.5em 0 !important;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 0.5em 0;
        }

        .formula-item .katex-display {
            margin: 0 !important;
        }

        /* Nuevos estilos para mejorar histogramas */
        .histogram-bar {
            border-radius: 2px;
        }

        .normal-curve-line {
            fill: none;
            stroke-width: 2;
        }

        /* Estilos para intervalos de confianza */
        .confidence-interval {
            font-size: 0.9em;
            color: #666;
            margin-top: 0.25rem;
            margin-left: 1.5rem;
        }

        .confidence-interval-label {
            font-weight: 600;
            color: #555;
        }

        .confidence-interval-value {
            font-weight: 600;
            color: #2c3e50;
        }

        /* Estilos para gráficas de normalidad */
        .qq-chart-container {
            height: 480px;
        }

        /* Subsecciones en resultados overall */
        .results-subsection {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid #eee;
        }

        .results-subsection-title {
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 0.75rem;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        @media (max-width: 768px) {

            .results-container,
            .overall-results-container,
            .dataset-results-wrapper {
                flex-direction: column;
            }

            .results-box {
                width: 100%;
                min-width: unset;
            }

            .charts-wrapper>div {
                height: 400px;
            }

            .button-group {
                justify-content: center;
            }

            .formula-grid {
                grid-template-columns: 1fr;
                width: 100%;
                max-width: 100%;
                overflow-x: hidden;
            }

            .katex {
                font-size: 0.9rem !important;
            }

            .anderson-formula {
                font-size: 0.85rem !important;
            }

            .chart-legend {
                flex-direction: column;
                align-items: flex-start;
            }

            .formula-item {
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                overflow-x: hidden;
            }

            .charts-wrapper {
                flex-direction: column;
            }

            .charts-wrapper>div {
                height: 400px;
            }

            .qq-chart-container {
                height: 400px;
            }
        }

        @media (max-width: 480px) {
            .button-group {
                flex-direction: column;
                align-items: stretch;
            }

            .button-group button {
                margin: 5px 0;
                width: 100%;
            }

            .charts-wrapper>div {
                height: 350px;
            }

            .container,
            .calculation-block {
                padding: 1rem;
            }

            .dataset-tabs {
                overflow-x: auto;
                flex-wrap: nowrap;
            }

            .qq-chart-container {
                height: 350px;
            }
        }
    </style>
</head>

<body>

    <div id="header-container"></div>

    <noscript>
        <nav>
            <a href="/">Home</a> |
            <a href="/8d">8D Tool</a> |
            <a href="/taguchi_doe">Taguchi DOE</a> |
            <a href="/swot">SWOT Analysis</a> |
            <a href="/balancedcard">Balanced Scorecard</a> |
            <a href="/qfd">QFD</a> |
            <a href="/apqp-ppap">APQP/PPAP</a> |
            <a href="/ishikawa">Ishikawa</a> |
            <a href="/fmea">FMEA</a> |
            <a href="/vave">VAVE</a> |
            <a href="/eisenhower">Eisenhower Matrix</a> |
            <a href="/triz">TRIZ</a> |
            <a href="/weibull">Weibull</a> |
            <a href="/stack_up_analysis">Tolerance Stack-Up</a> |
            <a href="/pdca">PDCA</a> |
            <a href="/design_thinking">Design Thinking</a> |
            <a href="/pugh">Pugh Matrix</a> |
            <a href="/cpk_calculator">CpK Calculator</a> |
            <a href="/control-plan">Control Plan</a>
        </nav>
    </noscript>

    <main class="main-content-wrapper">
        <header class="main-header">
            <h1><span
                    style="display: inline-flex; justify-content: center; align-items: center; width: 42px; height: 42px; background-color: #5ac8fa; border-radius: 8px; margin-right: 12px; vertical-align: middle;"><i
                        class="fas fa-chart-line" style="color: white; font-size: 22px;"></i></span> Free Online
                Capability Index Calculator (Cp, Cpk, Cpm, Pp, Ppk)</h1>
            <p>Calculate short-term (Cp, Cpk, Cpm) and long-term (Pp, Ppk) capability indices. Includes normality tests,
                distribution plots, and I-Charts for robust analysis.</p>
        </header>

        <div class="global-actions">
            <button class="global-btn secondary" id="globalFillExampleBtn">
                <i class="fas fa-play-circle"></i> Load Example Data
            </button>
            <button class="global-btn danger" id="globalResetDataBtn">
                <i class="fas fa-sync-alt"></i> Reset All Data
            </button>
        </div>

        <div class="tabs-container">
            <nav class="tabs-nav">
                <button class="tab-btn active" data-tab="tab-theory"><i class="fas fa-book"></i>
                    Theory & Info</button>
                <button class="tab-btn" data-tab="tab-tool"><i class="fas fa-calculator"></i>
                    Calculator Tool</button>
                <button class="tab-btn" data-tab="tab-results"><i class="fas fa-chart-bar"></i>
                    Results</button>
                <button class="tab-btn" data-tab="tab-formulas"><i class="fas fa-square-root-alt"></i>
                    Formulas</button>
            </nav>

            <div id="tab-theory" class="wizard-tab-content active">
                <div class="tab-content-wrapper">
                    <div class="container">
                        <h2><i class="fas fa-question-circle"></i> What is Process Capability (Cp, Cpk)?</h2>
                        <p>Process Capability analysis is a fundamental tool in Statistical Process Control (SPC) used
                            to measure the ability of a process to produce output within specification limits (LSL and
                            USL). It helps determine if a process is <em>capable</em> of consistently meeting customer
                            requirements.</p>
                        <p>This analysis uses key indices:</p>
                        <ul>
                            <li><strong>Cp (Process Capability):</strong> Measures the <em>potential</em> capability of
                                the process. It compares the total specification width (USL - LSL) to the natural
                                process variation (6-sigma), but it <strong>does not account for centering</strong>. It
                                answers: "Is the process spread narrow enough?"</li>
                            <li><strong>Cpk (Process Capability Index):</strong> Measures the <em>actual</em> capability
                                of the process. It accounts for <strong>both spread and centering</strong> by comparing
                                the process mean to the nearest specification limit. It answers: "Is the process spread
                                narrow enough AND is it running near the target?"</li>
                        </ul>
                        <p>Generally, a Cpk value of 1.33 or higher is considered capable for many industries, though
                            this requirement can vary.</p>
                    </div>

                    <div class="container">
                        <h2><i class="fas fa-history"></i> Brief History of Statistical Process Control (SPC)</h2>
                        <p>The concept of process control is rooted in the work of <strong>Walter A. Shewhart</strong>
                            at Bell Labs in the 1920s. He developed control charts to distinguish between "common cause"
                            variation (the natural, inherent variability of a process) and "special cause" variation
                            (external, unpredictable events). This was the birth of Statistical Process Control (SPC).
                        </p>
                    </div>

                    <div class="container">
                        <h2><i class="fas fa-cogs"></i> How to Use This Tool</h2>
                        <ol>
                            <li><strong>Enter Process Data and Specifications:</strong> Add one or more datasets using
                                the "Add Dataset" button. Fill in measurements for each dataset, along with the common
                                Lower (LSL), Upper (USL), and Target values.</li>
                            <li><strong>Calculate Results:</strong> Press the <strong>Calculate</strong> button. The
                                tool will compute short-term indices (Cp, Cpk, Cpm) for each dataset, overall long-term
                                indices (Pp, Ppk) combining all datasets, perform normality tests, and display process
                                distribution plots and Individuals Control Charts.</li>
                            <li><strong>Review Results:</strong> Analyze both the individual dataset results and the
                                overall performance. Switch between datasets using the tabs to see detailed results for
                                each one.</li>
                            <li><strong>Add or Remove Datasets (Optional):</strong> Use the "Add Dataset" button to
                                include more data or the "Remove" button next to each dataset to delete it.</li>
                            <li><strong>Export Your Analysis:</strong> Click <strong>Export to Excel</strong> to
                                download a spreadsheet containing all individual calculations and the overall
                                performance summary.</li>
                        </ol>
                    </div>

                    <div class="tab-nav-buttons">
                        <button class="btn-next-tab" data-next="tab-tool">Go to Calculator <i
                                class="fas fa-arrow-right"></i></button>
                    </div>
                </div>
            </div>

            <div id="tab-tool" class="wizard-tab-content">
                <div class="tab-content-wrapper">
                    <div class="calculator-section">
                        <div class="calculation-block">
                            <div class="calculation-title">Data Input</div>
                            <form id="cpkForm">
                                <div id="datasetsContainer">
                                    <div class="dataset-container" data-id="1">
                                        <div class="dataset-header">
                                            <span class="dataset-title">Measurements (Dataset #1)</span>
                                            <button type="button" class="remove-dataset-btn" style="display:none;"><i
                                                    class="fas fa-times"></i> Remove</button>
                                        </div>
                                        <textarea class="measurements-input" rows="1"
                                            placeholder="Enter values or click 'Load Example' above"
                                            required></textarea>
                                    </div>
                                </div>

                                <div class="datasets-controls">
                                    <button type="button" id="addDatasetBtn" class="button-yellow"><i
                                            class="fas fa-plus"></i> Add Dataset</button>
                                </div>

                                <label for="lsl"><i class="fas fa-arrow-down"></i> Lower Specification Limit
                                    (LSL):</label>
                                <input type="text" id="lsl" required />
                                <label for="usl"><i class="fas fa-arrow-up"></i> Upper Specification Limit
                                    (USL):</label>
                                <input type="text" id="usl" required />
                                <label for="target"><i class="fas fa-bullseye"></i> Target (T):</label>
                                <input type="text" id="target" required />

                                <div class="button-group" style="margin-top:0; margin-left:0;">
                                    <button type="submit"><i class="fas fa-calculator"></i> Calculate</button>
                                </div>
                            </form>
                        </div>
                    </div>
                </div>
            </div>

            <div id="tab-results" class="wizard-tab-content">
                <div class="tab-content-wrapper">
                    <!-- Pestañas para datasets y overall -->
                    <div id="datasetTabsContainer" class="dataset-tabs" style="display: none;"></div>

                    <!-- Contenedor para resultados del dataset activo -->
                    <div class="results-container">
                        <!-- Contenedor para resultados individuales de datasets -->
                        <div id="dataset-results-wrapper" class="dataset-results-wrapper">
                            <div class="results-box">
                                <div class="results-content">
                                    <div class="calculation-title">Short-Term Results</div>
                                    <p><i class="fas fa-chart-line"></i> Mean: <span id="mean"
                                            class="result-value">-</span>
                                    </p>
                                    <p><i class="fas fa-chart-bar"></i> Std Dev (short-term): <span id="deviation"
                                            class="result-value">-</span></p>
                                    <p><i class="fas fa-ruler-combined"></i> Cp: <span id="cp"
                                            class="result-value">-</span>
                                    <div class="confidence-interval" id="cp_ci">95% CI: -</div>
                                    </p>
                                    <p><i class="fas fa-tachometer-alt"></i> Cpk: <span id="cpk"
                                            class="result-value">-</span>
                                    <div class="confidence-interval" id="cpk_ci">95% CI: -</div>
                                    </p>
                                    <p><i class="fas fa-crosshairs"></i> Cpm: <span id="cpm"
                                            class="result-value">-</span>
                                    <div class="confidence-interval" id="cpm_ci">95% CI: -</div>
                                    </p>
                                    <p><i class="fas fa-exclamation-triangle"></i> Expected Failures: <span
                                            id="failures_ppm" class="result-value">-</span> ppm</p>
                                    <p><i class="fas fa-percentage"></i> Defective Parts: <span
                                            id="defective_percentage" class="result-value">-</span>%</p>

                                    <div class="normality-results">
                                        <div class="calculation-title"
                                            style="font-size: 1.1em; margin-top: 1rem; margin-bottom: 0.5rem;">Normality
                                            Tests</div>
                                        <p>Shapiro-Wilk: <span id="shapiro" class="result-value">-</span></p>
                                        <p>Kolmogorov-Smirnov: <span id="kolmogorov" class="result-value">-</span></p>
                                        <p>Anderson-Darling: <span id="anderson" class="result-value">-</span></p>
                                    </div>
                                </div>
                            </div>

                            <div class="charts-wrapper" id="short-term-charts-wrapper" style="display: none;">
                                <div id="cpkChart" class="cpk-chart-container">
                                    <img src="sigma-exacta-icon.jpg" alt="SigmaExacta Watermark"
                                        class="chart-watermark">
                                    <canvas id="cpkChartCanvas" class="chart-canvas"></canvas>
                                    <div class="chart-legend">
                                        <div class="legend-item">
                                            <div class="legend-color" style="background-color: #e74c3c;"></div> LSL/USL
                                        </div>
                                        <div class="legend-item">
                                            <div class="legend-color"
                                                style="background-color: #333; border-top: 2px dashed #333;"></div> Mean
                                        </div>
                                        <div class="legend-item">
                                            <div class="legend-color"
                                                style="background-color: #3498db; border-top: 2px solid #3498db;"></div>
                                            Process Limits (±3σ)
                                        </div>
                                        <div class="legend-item">
                                            <div class="legend-color" style="background-color: #3498db;"></div>
                                            Histogram
                                        </div>
                                        <div class="legend-item">
                                            <div class="legend-color" style="background-color: #2c3e50;"></div> Normal
                                            Curve
                                        </div>
                                    </div>
                                </div>
                                <div id="controlChartContainer" class="control-chart-container">
                                    <img src="sigma-exacta-icon.jpg" alt="SigmaExacta Watermark"
                                        class="chart-watermark">
                                    <canvas id="controlChartCanvas" class="chart-canvas"></canvas>
                                </div>
                                <div id="qqChartContainer" class="qq-chart-container" style="display: none;">
                                    <img src="sigma-exacta-icon.jpg" alt="SigmaExacta Watermark"
                                        class="chart-watermark">
                                    <canvas id="qqChartCanvas" class="chart-canvas"></canvas>
                                </div>
                            </div>
                        </div>

                        <!-- Contenedor para resultados overall (long-term) -->
                        <div id="overall-results-wrapper" class="dataset-results-wrapper">
                            <div class="results-box">
                                <div class="results-content">
                                    <div class="calculation-title">Overall Performance</div>
                                    <p><i class="fas fa-database"></i> <b>Total Points:</b> <span id="overall_total"
                                            class="result-value">1</span></p>
                                    <p><i class="fas fa-chart-line"></i> <b>Overall Mean:</b> <span id="overall_mean"
                                            class="result-value">-</span></p>

                                    <!-- Proceso Capability (Within) -->
                                    <div class="results-subsection">
                                        <div class="results-subsection-title">
                                            <i class="fas fa-bullseye"></i> Process Capability (Within)
                                        </div>
                                        <p><i class="fas fa-chart-bar"></i> <b>Std Dev (within):</b> <span
                                                id="overall_dev_short" class="result-value">-</span></p>
                                        <p><i class="fas fa-ruler-combined"></i> <b>Cp:</b> <span id="overall_cp_short"
                                                class="result-value">-</span>
                                        <div class="confidence-interval" id="overall_cp_short_ci">95% CI: -</div>
                                        </p>
                                        <p><i class="fas fa-tachometer-alt"></i> <b>Cpk:</b> <span
                                                id="overall_cpk_short" class="result-value">-</span>
                                        <div class="confidence-interval" id="overall_cpk_short_ci">95% CI: -</div>
                                        </p>
                                        <p><i class="fas fa-crosshairs"></i> <b>Cpm:</b> <span id="overall_cpm_short"
                                                class="result-value">-</span>
                                        <div class="confidence-interval" id="overall_cpm_short_ci">95% CI: -</div>
                                        </p>
                                    </div>

                                    <!-- Proceso Performance (Overall) -->
                                    <div class="results-subsection">
                                        <div class="results-subsection-title">
                                            <i class="fas fa-chart-line"></i> Process Performance (Overall)
                                        </div>
                                        <p><i class="fas fa-chart-bar"></i> <b>Std Dev (total):</b> <span
                                                id="overall_dev" class="result-value">-</span></p>
                                        <p><i class="fas fa-ruler-combined"></i> <b>Pp:</b> <span id="overall_pp"
                                                class="result-value">-</span>
                                        <div class="confidence-interval" id="overall_pp_ci">95% CI: -</div>
                                        </p>
                                        <p><i class="fas fa-tachometer-alt"></i> <b>Ppk:</b> <span id="overall_ppk"
                                                class="result-value">-</span>
                                        <div class="confidence-interval" id="overall_ppk_ci">95% CI: -</div>
                                        </p>
                                    </div>

                                    <div class="results-subsection">
                                        <p><i class="fas fa-exclamation-triangle"></i> <b>Expected Failures:</b> <span
                                                id="overall_failures" class="result-value">-</span> ppm</p>
                                        <p><i class="fas fa-percentage"></i> <b>Defective Parts:</b> <span
                                                id="overall_defective" class="result-value">-</span>%</p>
                                    </div>

                                    <div class="normality-results">
                                        <div class="calculation-title"
                                            style="font-size:1.1em;margin-top:1rem;margin-bottom:.5rem">Overall
                                            Normality</div>
                                        <p>Shapiro-Wilk: <span id="overall_shapiro" class="result_value">-</span></p>
                                        <p>Kolmogorov-Smirnov: <span id="overall_kolmogorov"
                                                class="result_value">-</span></p>
                                        <p>Anderson-Darling: <span id="overall_anderson" class="result_value">-</span>
                                        </p>
                                    </div>
                                </div>
                            </div>

                            <div class="charts-wrapper" id="long-term-charts-wrapper" style="display: none;">
                                <div id="overallChartContainer" class="overall-chart-container">
                                    <img src="sigma-exacta-icon.jpg" alt="SigmaExacta Watermark"
                                        class="chart-watermark">
                                    <canvas id="overallChartCanvas" class="chart-canvas"></canvas>
                                    <div class="chart-legend">
                                        <div class="legend-item">
                                            <div class="legend-color" style="background-color: #e74c3c;"></div> LSL/USL
                                        </div>
                                        <div class="legend-item">
                                            <div class="legend-color"
                                                style="background-color: #333; border-top: 2px dashed #333;"></div> Mean
                                        </div>
                                        <div class="legend-item">
                                            <div class="legend-color"
                                                style="background-color: #3498db; border-top: 2px solid #3498db;"></div>
                                            Process Limits (±3σ)
                                        </div>
                                        <div class="legend-item">
                                            <div class="legend-color" style="background-color: #3498db;"></div>
                                            Histogram
                                        </div>
                                        <div class="legend-item">
                                            <div class="legend-color" style="background-color: #2c3e50;"></div> Normal
                                            Curve
                                        </div>
                                    </div>
                                </div>
                                <div id="overallControlChartContainer" class="overall-control-chart-container">
                                    <img src="sigma-exacta-icon.jpg" alt="SigmaExacta Watermark"
                                        class="chart-watermark">
                                    <canvas id="overallControlChartCanvas" class="chart-canvas"></canvas>
                                </div>
                                <div id="overallQQChartContainer" class="qq-chart-container" style="display: none;">
                                    <img src="sigma-exacta-icon.jpg" alt="SigmaExacta Watermark"
                                        class="chart-watermark">
                                    <canvas id="overallQQChartCanvas" class="chart-canvas"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Botón de exportar (común para todos los datasets) -->
                    <div class="button-group" style="margin-top: 20px; justify-content: flex-start;">
                        <button type="button" id="exportBtn" class="button-green" disabled><i
                                class="fas fa-file-excel"></i> Export to Excel</button>
                    </div>
                </div>
            </div>

            <div id="tab-formulas" class="wizard-tab-content">
                <div class="tab-content-wrapper">
                    <div class="container">
                        <h2><i class="fas fa-calculator"></i> Mathematical Formulas</h2>
                        <div class="formula-grid">
                            <div class="formula-item">
                                <h3>Sigma Within (Short-Term)</h3>
                                <div class="katex-content">$$ \sigma_{\text{within}} = \frac{\overline{MR}}{d_2} $$
                                </div>
                                <p>Where $d_2 = 1.128$ for $n=2$</p>
                            </div>
                            <div class="formula-item">
                                <h3>Cp (Capability)</h3>
                                <div class="katex-content">$$ C_p = \frac{USL - LSL}{6\sigma_{\text{within}}} $$</div>
                            </div>
                            <div class="formula-item">
                                <h3>Cpk (Centering)</h3>
                                <div class="katex-content">$$ C_{pk} = \min\left( \frac{USL -
                                    \mu}{3\sigma_{\text{within}}}, \frac{\mu - LSL}{3\sigma_{\text{within}}} \right)
                                    $$</div>
                            </div>
                            <div class="formula-item">
                                <h3>Cpm (Targeting)</h3>
                                <div class="katex-content">$$ C_{pm} = \frac{USL -
                                    LSL}{6\sqrt{\sigma_{\text{within}}^2 + (\mu - T)^2}} $$</div>
                            </div>
                            <div class="formula-item">
                                <h3>Pp (Performance)</h3>
                                <div class="katex-content">$$ P_p = \frac{USL - LSL}{6\sigma_{\text{overall}}} $$</div>
                            </div>
                            <div class="formula-item">
                                <h3>Ppk (Centering)</h3>
                                <div class="katex-content">$$ P_{pk} = \min\left( \frac{USL -
                                    \mu}{3\sigma_{\text{overall}}}, \frac{\mu - LSL}{3\sigma_{\text{overall}}} \right)
                                    $$</div>
                            </div>
                            <div class="formula-item">
                                <h3>Confidence Interval for Cp</h3>
                                <div class="katex-content">$$ CI_{Cp} = C_p \pm Z_{\alpha/2} \sqrt{\frac{1}{2(n-1)}} $$
                                </div>
                            </div>
                            <div class="formula-item">
                                <h3>Confidence Interval for Cpk</h3>
                                <div class="katex-content">$$ CI_{Cpk} = C_{pk} \pm Z_{\alpha/2} \sqrt{\frac{1}{9n} +
                                    \frac{C_{pk}^2}{2(n-1)}} $$</div>
                            </div>
                        </div>
                        <div class="legend">
                            <h3>Capability Legend</h3>
                            <ul>
                                <li><code>Cp, Pp</code>: Process Capability/Performance - measures potential capability
                                    if process is centered</li>
                                <li><code>Cpk, Ppk</code>: Process Capability/Performance Index - accounts for process
                                    centering</li>
                                <li><code>Cpm</code>: Process Capability Index considering target value</li>
                                <li><code>LSL, USL</code>: Lower and Upper Specification Limits</li>
                                <li><code>T</code>: Target value</li>
                                <li><code>μ</code>: Process mean</li>
                                <li><code>σ<sub>within</sub></code>: Short-term standard deviation (within-subgroup
                                    variation)</li>
                                <li><code>σ<sub>overall</sub></code>: Long-term standard deviation (overall variation)
                                </li>
                                <li><code>CI</code>: Confidence Interval (95% by default)</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <footer>
        <div class="disclaimer-note">
            <p><strong>Disclaimer:</strong> The tools and information provided on Sigma Exacta are for informational and
                educational purposes only. This tool is based on established methodologies in Statistical Process
                Control (SPC) and Six Sigma. Normality tests like Shapiro-Wilk and Anderson-Darling are complex and the
                versions implemented here are approximations suitable for educational guidance; for critical
                applications, consult specialized statistical software. All calculations, quality control decisions, and
                process adjustments based on the output of this tool are the sole responsibility of the user. Sigma
                Exacta and its creators are not liable for any damages or losses resulting from the use of this website.
            </p>
        </div>
    </footer>

    <!-- Scripts al final del body para mejor rendimiento -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"
        integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
        integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05"
        crossorigin="anonymous"></script>

    <script>
        // Variable para controlar si KaTeX ya se ha renderizado
        let katexRendered = false;

        // Función para cambiar entre pestañas del wizard
        function switchWizardTab(tabId) {
            // Quitar clase active de todos los botones y contenidos de wizard
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.wizard-tab-content').forEach(content => content.classList.remove('active'));

            // Activar el contenido seleccionado
            const activeTab = document.getElementById(tabId);
            activeTab.classList.add('active');

            // Activar botón correspondiente
            const activeBtn = document.querySelector(`.tab-btn[data-tab="${tabId}"]`);
            if (activeBtn) activeBtn.classList.add('active');

            // Scroll al top suavemente
            window.scrollTo({ top: 0, behavior: 'smooth' });

            // Renderizar KaTeX cuando se active la pestaña de fórmulas
            if (tabId === 'tab-formulas' && !katexRendered) {
                setTimeout(renderKaTeX, 100);
            }
        }

        // Función para renderizar KaTeX
        function renderKaTeX() {
            if (window.renderMathInElement && !katexRendered) {
                // Renderizar solo en el contenedor de fórmulas
                const mathElements = document.getElementById('tab-formulas');
                if (mathElements) {
                    renderMathInElement(mathElements, {
                        delimiters: [
                            { left: '$$', right: '$$', display: true },
                            { left: '$', right: '$', display: false },
                            { left: '\\(', right: '\\)', display: false },
                            { left: '\\[', right: '\\]', display: true }
                        ],
                        throwOnError: false,
                        strict: false
                    });
                    katexRendered = true;
                    console.log('KaTeX renderizado correctamente');
                }
            }
        }

        // Inicializar cuando el DOM esté listo
        document.addEventListener('DOMContentLoaded', function () {
            // Configurar event listeners para las pestañas
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', function () {
                    const tabId = this.getAttribute('data-tab');
                    switchWizardTab(tabId);
                });
            });

            // Configurar botones de navegación
            document.querySelectorAll('.btn-next-tab').forEach(btn => {
                btn.addEventListener('click', function () {
                    const nextTab = this.getAttribute('data-next');
                    switchWizardTab(nextTab);
                });
            });

            // Renderizar KaTeX inicialmente si la pestaña de fórmulas está activa
            if (document.getElementById('tab-formulas').classList.contains('active')) {
                setTimeout(renderKaTeX, 300);
            }

            // Configurar botones globales
            const globalFillBtn = document.getElementById('globalFillExampleBtn');
            const globalResetBtn = document.getElementById('globalResetDataBtn');
            const form = document.getElementById('cpkForm');

            // Crear botones ocultos para que el script original funcione
            const fillExampleBtn = document.createElement('button');
            fillExampleBtn.id = 'fillExampleBtn';
            fillExampleBtn.style.display = 'none';

            const resetDataBtn = document.createElement('button');
            resetDataBtn.id = 'resetDataBtn';
            resetDataBtn.style.display = 'none';

            // Añadir botones ocultos al body
            document.body.appendChild(fillExampleBtn);
            document.body.appendChild(resetDataBtn);

            if (globalFillBtn && fillExampleBtn) {
                globalFillBtn.addEventListener('click', function () {
                    // Cambiar a la pestaña de calculadora
                    switchWizardTab('tab-tool');

                    // Disparar el clic en el botón de ejemplo original
                    setTimeout(function () {
                        fillExampleBtn.click();

                        // Scroll a la sección de entrada de datos
                        setTimeout(function () {
                            const calculatorSection = document.querySelector('#tab-tool .calculator-section');
                            if (calculatorSection) {
                                calculatorSection.scrollIntoView({ behavior: 'smooth' });
                            }
                        }, 100);
                    }, 100);
                });
            }

            if (globalResetBtn && resetDataBtn) {
                globalResetBtn.addEventListener('click', function () {
                    // Disparar el clic en el botón de reset original
                    resetDataBtn.click();

                    // Cambiar a la pestaña de calculadora
                    switchWizardTab('tab-tool');
                });
            }

            // Modificar el formulario para que al calcular cambie a la pestaña de resultados
            if (form) {
                form.addEventListener('submit', function (e) {
                    // Esperar un momento para que el cálculo se complete
                    setTimeout(function () {
                        // Cambiar a la pestaña de resultados
                        switchWizardTab('tab-results');

                        // Scroll a la sección de resultados
                        setTimeout(function () {
                            const resultsTab = document.getElementById('tab-results');
                            if (resultsTab) {
                                resultsTab.scrollIntoView({ behavior: 'smooth' });
                            }
                        }, 100);
                    }, 300);
                });
            }

            // Asegurar que los gráficos tengan la marca de agua correctamente posicionada
            setTimeout(function () {
                document.querySelectorAll('.charts-wrapper > div').forEach(container => {
                    if (!container.querySelector('.chart-watermark')) {
                        const watermark = document.createElement('img');
                        watermark.src = 'sigma-exacta-icon.jpg';
                        watermark.alt = 'SigmaExacta Watermark';
                        watermark.className = 'chart-watermark';
                        container.appendChild(watermark);
                    }
                });
            }, 1000);
        });

        // También intentar renderizar KaTeX cuando la página esté completamente cargada
        window.addEventListener('load', function () {
            if (document.getElementById('tab-formulas').classList.contains('active') && !katexRendered) {
                setTimeout(renderKaTeX, 500);
            }
        });
    </script>

    <!-- Script de la calculadora CpK - CORREGIDO -->
    <script>
        // Load header
        fetch('header.html')
            .then(response => response.text())
            .then(data => {
                document.getElementById('header-container').innerHTML = data;
                // Initialize navigation after header is loaded
                initNavigation();
            });

        function initNavigation() {
            const navToggle = document.getElementById('nav-toggle');
            const navMenu = document.getElementById('nav-menu');
            const dropdownContainer = document.getElementById('tools-dropdown-container');
            const toolsDropdownToggle = document.getElementById('tools-dropdown-toggle');
            const dropdownMenu = document.getElementById('tools-dropdown-menu');

            if (navToggle && navMenu) {
                navToggle.addEventListener('click', function () {
                    navMenu.classList.toggle('show-menu');
                });
            }

            if (toolsDropdownToggle && dropdownMenu) {
                toolsDropdownToggle.addEventListener('click', function (e) {
                    if (window.innerWidth <= 992) {
                        e.preventDefault();
                        const isSubmenuOpen = dropdownMenu.classList.toggle('show-submenu');
                        dropdownContainer.classList.toggle('active', isSubmenuOpen);
                    }
                });
            }
        }

        document.addEventListener('DOMContentLoaded', function () {
            // Configuración y variables globales
            let datasets = [];
            let currentDatasetId = 1;
            let overallData = [];
            let chartInstances = {
                cpkChart: null,
                controlChart: null,
                overallChart: null,
                overallControlChart: null,
                qqChart: null,
                overallQQChart: null
            };

            let exampleIndex = 0;
            let overallStats = null; // Variable para almacenar resultados overall

            const exampleDataSetsCollection = [
                // Example Set 1 (Three Datasets: Centered, Shifted, Spread)
                {
                    lsl: 9.0, usl: 11.0, target: 10.0,
                    datasets: [
                        // Dataset 1: Centered (Good Cpk)
                        { id: 1, data: ["10.05", "10.15", "10.02", "10.08", "10.10", "10.03", "10.07", "10.12", "10.01", "10.06", "10.11", "10.04", "10.09", "10.14", "10.00", "10.13", "10.05", "10.10", "10.03", "10.07"] },
                        // Dataset 2: Shifted High (Acceptable Cpk, Ppk may be lower)
                        { id: 2, data: ["10.65", "10.70", "10.68", "10.75", "10.71", "10.64", "10.69", "10.72", "10.73", "10.67", "10.74", "10.66", "10.70", "10.75", "10.68", "10.71", "10.65", "10.72", "10.66", "10.73"] },
                        // Dataset 3: High Variation (Poor Cpk, risk of failure)
                        { id: 3, data: ["11.05", "10.55", "9.50", "11.50", "10.85", "10.00", "11.20", "10.40", "9.75", "11.40", "10.60", "9.90", "11.30", "10.20", "9.60", "11.10", "10.30", "9.80", "11.60", "10.70"] }
                    ]
                },
                // Example Set 2 (Two Datasets: Original, but with updated LSL/USL)
                {
                    lsl: 8.5, usl: 12.5, target: 10.5,
                    datasets: [
                        { id: 1, data: ["10.15", "10.22", "10.05", "10.30", "10.18", "10.09", "10.35", "10.25", "10.19", "10.42", "10.33", "10.10", "10.28", "10.38", "10.16", "10.29", "10.11", "10.23", "10.08", "10.14", "10.20", "10.26", "10.12", "10.31", "10.17", "10.24", "10.06", "10.32", "10.13", "10.27", "10.15", "10.22", "10.05", "10.30", "10.18", "10.09", "10.35", "10.25", "10.19", "10.42", "10.33", "10.10", "10.28", "10.38", "10.16", "10.29", "10.11", "10.23", "10.08", "10.14"] },
                        { id: 2, data: ["10.55", "10.62", "10.45", "10.70", "10.58", "10.49", "10.75", "10.65", "10.59", "10.82", "10.73", "10.50", "10.68", "10.78", "10.56", "10.69", "10.51", "10.63", "10.48", "10.54", "10.60", "10.66", "10.52", "10.71", "10.57", "10.64", "10.46", "10.72", "10.53", "10.67", "10.55", "10.62", "10.45", "10.70", "10.58", "10.49", "10.75", "10.65", "10.59", "10.82", "10.73", "10.50", "10.68", "10.78", "10.56", "10.69", "10.51", "10.63", "10.48", "10.54"] }
                    ]
                }
            ];

            // Event Listeners
            document.getElementById('cpkForm').addEventListener('submit', handleFormSubmit);

            // Crear botones ocultos para ejemplo y reset si no existen
            if (!document.getElementById('fillExampleBtn')) {
                const fillExampleBtn = document.createElement('button');
                fillExampleBtn.id = 'fillExampleBtn';
                fillExampleBtn.style.display = 'none';
                document.body.appendChild(fillExampleBtn);
            }

            if (!document.getElementById('resetDataBtn')) {
                const resetDataBtn = document.createElement('button');
                resetDataBtn.id = 'resetDataBtn';
                resetDataBtn.style.display = 'none';
                document.body.appendChild(resetDataBtn);
            }

            document.getElementById('fillExampleBtn').addEventListener('click', fillExampleData);
            document.getElementById('resetDataBtn').addEventListener('click', resetFormData);
            document.getElementById('exportBtn').addEventListener('click', exportToExcel);
            document.getElementById('addDatasetBtn').addEventListener('click', addNewDataset);

            function handleFormSubmit(e) {
                e.preventDefault();

                const lsl = parseFloat(document.getElementById('lsl').value);
                const usl = parseFloat(document.getElementById('usl').value);
                const target = parseFloat(document.getElementById('target').value);

                if (isNaN(lsl) || isNaN(usl) || isNaN(target) || usl <= lsl) {
                    alert('Please enter valid LSL, USL, and Target values. USL must be greater than LSL.');
                    return;
                }

                datasets = [];
                overallData = [];

                // Primero, procesar cada dataset individualmente
                document.querySelectorAll('.dataset-container').forEach(function (el) {
                    const id = parseInt(el.dataset.id);
                    const measurements = parseMeasurements(el.querySelector('.measurements-input').value);
                    if (measurements.length >= 2) {
                        const stats = calculateDatasetStatistics(measurements, lsl, usl, target);
                        datasets.push({
                            id: id,
                            measurements: measurements,
                            ...stats
                        });
                        overallData.push.apply(overallData, measurements);
                    }
                });

                if (datasets.length === 0) {
                    alert('No valid datasets with enough data (minimum 2 data points).');
                    return;
                }

                // Calcular pooled sigma within (método estadístico correcto)
                const pooledSigmaWithin = calculatePooledSigmaWithin(datasets);

                // Calcular estadísticas overall usando método corregido
                if (overallData.length >= 2) {
                    overallStats = calculateOverallStatistics(overallData, lsl, usl, target, pooledSigmaWithin);
                } else {
                    overallStats = null;
                }

                // Mostrar los resultados del primer dataset
                if (datasets.length > 0) {
                    displayResults(datasets[0], 0);
                }
                updateDatasetTabs();

                document.getElementById('exportBtn').disabled = false;
            }

            // NUEVA FUNCIÓN: Calcular pooled sigma within (método estadístico correcto)
            function calculatePooledSigmaWithin(datasets) {
                if (datasets.length === 0) return 0;

                if (datasets.length === 1) {
                    // Si solo hay un dataset, usar su sigma within directamente
                    return datasets[0].sigmaWithin;
                }

                // Calcular pooled variance: s²_pooled = Σ[(n_i - 1) * s_i²] / Σ(n_i - 1)
                let sumSquaredDeviations = 0;
                let totalDegreesOfFreedom = 0;

                datasets.forEach(dataset => {
                    const n = dataset.measurements.length;
                    if (n > 1) {
                        const df = n - 1;
                        const variance = Math.pow(dataset.sigmaWithin, 2);
                        sumSquaredDeviations += df * variance;
                        totalDegreesOfFreedom += df;
                    }
                });

                if (totalDegreesOfFreedom === 0) return 0;

                const pooledVariance = sumSquaredDeviations / totalDegreesOfFreedom;
                return Math.sqrt(pooledVariance);
            }

            function parseMeasurements(text) {
                return text.split(/[\s,;]+/).map(function (val) {
                    return parseFloat(val.trim());
                }).filter(function (val) {
                    return !isNaN(val);
                });
            }

            // Función para calcular estadísticas de un dataset individual
            function calculateDatasetStatistics(data, lsl, usl, target) {
                if (data.length < 2) return null;
                const n = data.length;

                // Verificar si todos los valores son iguales
                const allEqual = data.every(val => val === data[0]);

                if (allEqual) {
                    const mean = data[0];
                    const centered = (mean > lsl && mean < usl);
                    const onTarget = (mean === target);

                    if (centered) {
                        return {
                            mean: mean,
                            sigmaWithin: 0,
                            sigmaOverall: 0,
                            mrBar: 0,
                            cp: Infinity,
                            cpk: Infinity,
                            cpm: onTarget ? Infinity : 0,
                            pp: Infinity,
                            ppk: Infinity,
                            failures_ppm: 0,
                            defective_percentage: 0,
                            failures_ppm_lt: 0,
                            defective_percentage_lt: 0,
                            shapiro: { statistic: 1.0, pValue: 1.0, result: 'Pass', message: 'All values identical' },
                            kolmogorov: { statistic: 0, pValue: 1.0, result: 'Pass', message: 'All values identical' },
                            anderson: { statistic: 0, pValue: 1.0, result: 'Pass', message: 'All values identical' }
                        };
                    } else {
                        return {
                            mean: mean,
                            sigmaWithin: 0,
                            sigmaOverall: 0,
                            mrBar: 0,
                            cp: 0,
                            cpk: 0,
                            cpm: 0,
                            pp: 0,
                            ppk: 0,
                            failures_ppm: 1000000,
                            defective_percentage: 100,
                            failures_ppm_lt: 1000000,
                            defective_percentage_lt: 100,
                            shapiro: { statistic: 1.0, pValue: 1.0, result: 'Pass', message: 'All values identical' },
                            kolmogorov: { statistic: 0, pValue: 1.0, result: 'Pass', message: 'All values identical' },
                            anderson: { statistic: 0, pValue: 1.0, result: 'Pass', message: 'All values identical' }
                        };
                    }
                }

                const mean = data.reduce(function (a, b) { return a + b; }, 0) / n;

                // Calcular sigma within usando moving ranges (exact method)
                const movingRanges = [];
                for (let i = 1; i < data.length; i++) {
                    movingRanges.push(Math.abs(data[i] - data[i - 1]));
                }
                const mrBar = movingRanges.reduce(function (a, b) { return a + b; }, 0) / movingRanges.length;
                const sigmaWithin = mrBar / 1.128; // d2 for n=2

                // Calcular sigma overall (traditional standard deviation)
                const variance = data.reduce(function (a, b) { return a + Math.pow(b - mean, 2); }, 0) / (n - 1);
                const sigmaOverall = Math.sqrt(variance);

                // Calculate short-term indices using sigma within
                const cp = (usl - lsl) / (6 * sigmaWithin);
                const cpk = Math.min((usl - mean) / (3 * sigmaWithin), (mean - lsl) / (3 * sigmaWithin));
                const cpm = (usl - lsl) / (6 * Math.sqrt(Math.pow(sigmaWithin, 2) + Math.pow(mean - target, 2)));

                // Calculate long-term indices using sigma overall
                const pp = (usl - lsl) / (6 * sigmaOverall);
                const ppk = Math.min((usl - mean) / (3 * sigmaOverall), (mean - lsl) / (3 * sigmaOverall));

                // Cálculo de defectos
                const zUpperST = (usl - mean) / sigmaWithin;
                const zLowerST = (lsl - mean) / sigmaWithin;
                const probDefectiveST = (1 - normalCDF(zUpperST)) + normalCDF(zLowerST);

                const zUpperLT = (usl - mean) / sigmaOverall;
                const zLowerLT = (lsl - mean) / sigmaOverall;
                const probDefectiveLT = (1 - normalCDF(zUpperLT)) + normalCDF(zLowerLT);

                // Calcular intervalos de confianza
                const confidenceLevel = 0.95;
                const cpCI = calculateCpConfidenceInterval(cp, n, confidenceLevel);
                const cpkCI = calculateCpkConfidenceInterval(cpk, n, confidenceLevel);
                const cpmCI = calculateCpmConfidenceInterval(cpm, n, confidenceLevel);
                const ppCI = calculateCpConfidenceInterval(pp, n, confidenceLevel);
                const ppkCI = calculateCpkConfidenceInterval(ppk, n, confidenceLevel);

                return {
                    mean: mean,
                    sigmaWithin: sigmaWithin,
                    sigmaOverall: sigmaOverall,
                    mrBar: mrBar,
                    cp: cp,
                    cpk: cpk,
                    cpm: cpm,
                    pp: pp,
                    ppk: ppk,
                    failures_ppm: probDefectiveST * 1e6,
                    defective_percentage: probDefectiveST * 100,
                    failures_ppm_lt: probDefectiveLT * 1e6,
                    defective_percentage_lt: probDefectiveLT * 100,
                    shapiro: shapiroWilkTest(data),
                    kolmogorov: kolmogorovSmirnovTest(data),
                    anderson: andersonDarlingTest(data),
                    cpCI: cpCI,
                    cpkCI: cpkCI,
                    cpmCI: cpmCI,
                    ppCI: ppCI,
                    ppkCI: ppkCI
                };
            }

            // Función para calcular estadísticas overall - CORREGIDA
            function calculateOverallStatistics(data, lsl, usl, target, sigmaWithin) {
                if (data.length < 2) return null;
                const n = data.length;

                // Verificar si todos los valores son iguales
                const allEqual = data.every(val => val === data[0]);

                if (allEqual) {
                    const mean = data[0];
                    const centered = (mean > lsl && mean < usl);
                    const onTarget = (mean === target);

                    if (centered) {
                        return {
                            mean: mean,
                            sigmaWithin: 0,
                            sigmaOverall: 0,
                            cp: Infinity,
                            cpk: Infinity,
                            cpm: onTarget ? Infinity : 0,
                            pp: Infinity,
                            ppk: Infinity,
                            failures_ppm: 0,
                            defective_percentage: 0,
                            failures_ppm_lt: 0,
                            defective_percentage_lt: 0,
                            shapiro: { statistic: 1.0, pValue: 1.0, result: 'Pass', message: 'All values identical' },
                            kolmogorov: { statistic: 0, pValue: 1.0, result: 'Pass', message: 'All values identical' },
                            anderson: { statistic: 0, pValue: 1.0, result: 'Pass', message: 'All values identical' }
                        };
                    } else {
                        return {
                            mean: mean,
                            sigmaWithin: 0,
                            sigmaOverall: 0,
                            cp: 0,
                            cpk: 0,
                            cpm: 0,
                            pp: 0,
                            ppk: 0,
                            failures_ppm: 1000000,
                            defective_percentage: 100,
                            failures_ppm_lt: 1000000,
                            defective_percentage_lt: 100,
                            shapiro: { statistic: 1.0, pValue: 1.0, result: 'Pass', message: 'All values identical' },
                            kolmogorov: { statistic: 0, pValue: 1.0, result: 'Pass', message: 'All values identical' },
                            anderson: { statistic: 0, pValue: 1.0, result: 'Pass', message: 'All values identical' }
                        };
                    }
                }

                const mean = data.reduce(function (a, b) { return a + b; }, 0) / n;

                // Calcular sigma overall (traditional standard deviation)
                const variance = data.reduce(function (a, b) { return a + Math.pow(b - mean, 2); }, 0) / (n - 1);
                const sigmaOverall = Math.sqrt(variance);

                // USAR el sigma within proporcionado (pooled sigma within)
                const effectiveSigmaWithin = sigmaWithin || 1e-10;

                // Calculate short-term indices usando sigma within proporcionado
                const cp = (usl - lsl) / (6 * effectiveSigmaWithin);
                const cpk = Math.min(
                    (usl - mean) / (3 * effectiveSigmaWithin),
                    (mean - lsl) / (3 * effectiveSigmaWithin)
                );
                const cpm = (usl - lsl) / (6 * Math.sqrt(
                    Math.pow(effectiveSigmaWithin, 2) + Math.pow(mean - target, 2)
                ));

                // Calculate long-term indices usando sigma overall
                const pp = (usl - lsl) / (6 * sigmaOverall);
                const ppk = Math.min(
                    (usl - mean) / (3 * sigmaOverall),
                    (mean - lsl) / (3 * sigmaOverall)
                );

                // Cálculo de defectos
                const zUpperST = (usl - mean) / effectiveSigmaWithin;
                const zLowerST = (lsl - mean) / effectiveSigmaWithin;
                const probDefectiveST = (1 - normalCDF(zUpperST)) + normalCDF(zLowerST);

                const zUpperLT = (usl - mean) / sigmaOverall;
                const zLowerLT = (lsl - mean) / sigmaOverall;
                const probDefectiveLT = (1 - normalCDF(zUpperLT)) + normalCDF(zLowerLT);

                // Calcular intervalos de confianza
                const confidenceLevel = 0.95;
                const cpCI = calculateCpConfidenceInterval(cp, n, confidenceLevel);
                const cpkCI = calculateCpkConfidenceInterval(cpk, n, confidenceLevel);
                const cpmCI = calculateCpmConfidenceInterval(cpm, n, confidenceLevel);
                const ppCI = calculateCpConfidenceInterval(pp, n, confidenceLevel);
                const ppkCI = calculateCpkConfidenceInterval(ppk, n, confidenceLevel);

                return {
                    mean: mean,
                    sigmaWithin: effectiveSigmaWithin,
                    sigmaOverall: sigmaOverall,
                    cp: cp,
                    cpk: cpk,
                    cpm: cpm,
                    pp: pp,
                    ppk: ppk,
                    failures_ppm: probDefectiveST * 1e6,
                    defective_percentage: probDefectiveST * 100,
                    failures_ppm_lt: probDefectiveLT * 1e6,
                    defective_percentage_lt: probDefectiveLT * 100,
                    shapiro: shapiroWilkTest(data),
                    kolmogorov: kolmogorovSmirnovTest(data),
                    anderson: andersonDarlingTest(data),
                    cpCI: cpCI,
                    cpkCI: cpkCI,
                    cpmCI: cpmCI,
                    ppCI: ppCI,
                    ppkCI: ppkCI
                };
            }

            // ====================================================================
            // FUNCIONES PARA INTERVALOS DE CONFIANZA
            // ====================================================================

            function calculateCpConfidenceInterval(cp, n, confidenceLevel) {
                if (n <= 1 || !isFinite(cp) || cp === 0) {
                    return { lower: NaN, upper: NaN };
                }

                const alpha = 1 - confidenceLevel;
                const z = Math.abs(normalQuantile(1 - alpha / 2));
                const se = cp * Math.sqrt(1 / (2 * (n - 1)));

                return {
                    lower: Math.max(0, cp - z * se),
                    upper: cp + z * se
                };
            }

            function calculateCpkConfidenceInterval(cpk, n, confidenceLevel) {
                if (n <= 1 || !isFinite(cpk)) {
                    return { lower: NaN, upper: NaN };
                }

                const alpha = 1 - confidenceLevel;
                const z = Math.abs(normalQuantile(1 - alpha / 2));
                const se = Math.sqrt(1 / (9 * n) + Math.pow(cpk, 2) / (2 * (n - 1)));

                return {
                    lower: Math.max(0, cpk - z * se),
                    upper: cpk + z * se
                };
            }

            function calculateCpmConfidenceInterval(cpm, n, confidenceLevel) {
                if (n <= 1 || !isFinite(cpm) || cpm === 0) {
                    return { lower: NaN, upper: NaN };
                }

                // Aproximación para Cpm
                const alpha = 1 - confidenceLevel;
                const z = Math.abs(normalQuantile(1 - alpha / 2));
                const se = cpm * Math.sqrt(1 / (n - 1));

                return {
                    lower: Math.max(0, cpm - z * se),
                    upper: cpm + z * se
                };
            }

            function formatConfidenceInterval(ci) {
                if (!ci || isNaN(ci.lower) || isNaN(ci.upper)) {
                    return '[N/A]';
                }
                return `[${ci.lower.toFixed(4)}, ${ci.upper.toFixed(4)}]`;
            }

            function displayResults(dataset, index) {
                // Mostrar el contenedor de resultados individuales
                document.getElementById('dataset-results-wrapper').classList.add('active');
                document.getElementById('short-term-charts-wrapper').style.display = 'flex';

                // Ocultar overall si está visible
                document.getElementById('overall-results-wrapper').classList.remove('active');
                document.getElementById('long-term-charts-wrapper').style.display = 'none';

                document.getElementById('mean').textContent = isFinite(dataset.mean) ? dataset.mean.toFixed(4) : 'N/A';
                document.getElementById('deviation').textContent = isFinite(dataset.sigmaWithin) ? dataset.sigmaWithin.toFixed(4) : 'N/A';
                document.getElementById('cp').textContent = isFinite(dataset.cp) ? dataset.cp.toFixed(4) : 'N/A';
                document.getElementById('cp_ci').textContent = `95% CI: ${formatConfidenceInterval(dataset.cpCI)}`;
                document.getElementById('cpk').textContent = isFinite(dataset.cpk) ? dataset.cpk.toFixed(4) : 'N/A';
                document.getElementById('cpk_ci').textContent = `95% CI: ${formatConfidenceInterval(dataset.cpkCI)}`;
                document.getElementById('cpm').textContent = isFinite(dataset.cpm) ? dataset.cpm.toFixed(4) : 'N/A';
                document.getElementById('cpm_ci').textContent = `95% CI: ${formatConfidenceInterval(dataset.cpmCI)}`;
                document.getElementById('failures_ppm').textContent = dataset.failures_ppm.toFixed(2);
                document.getElementById('defective_percentage').textContent = dataset.defective_percentage.toFixed(4);

                document.getElementById('shapiro').innerHTML = formatNormalityResult(dataset.shapiro);
                document.getElementById('kolmogorov').innerHTML = formatNormalityResult(dataset.kolmogorov);
                document.getElementById('anderson').innerHTML = formatNormalityResult(dataset.anderson);

                plotChart(dataset.mean, dataset.sigmaWithin, parseFloat(document.getElementById('lsl').value),
                    parseFloat(document.getElementById('usl').value), dataset.measurements, index);
                createControlChart(dataset, index);
                createQQPlot(dataset.measurements, 'qqChartCanvas', 'Q-Q Plot - Dataset #' + (index + 1));

                // Mostrar el contenedor del gráfico Q-Q
                document.getElementById('qqChartContainer').style.display = 'block';
            }

            function displayOverallResults(stats) {
                // Solo mostrar resultados overall cuando se activa la pestaña overall
                document.getElementById('overall-results-wrapper').classList.add('active');
                document.getElementById('long-term-charts-wrapper').style.display = 'flex';

                // Ocultar resultados individuales
                document.getElementById('dataset-results-wrapper').classList.remove('active');
                document.getElementById('short-term-charts-wrapper').style.display = 'none';

                document.getElementById('overall_total').textContent = overallData.length;
                document.getElementById('overall_mean').textContent = isFinite(stats.mean) ? stats.mean.toFixed(4) : 'N/A';

                // Mostrar valores short-term para overall (Process Capability)
                document.getElementById('overall_dev_short').textContent = isFinite(stats.sigmaWithin) ? stats.sigmaWithin.toFixed(4) : 'N/A';
                document.getElementById('overall_cp_short').textContent = isFinite(stats.cp) ? stats.cp.toFixed(4) : 'N/A';
                document.getElementById('overall_cp_short_ci').textContent = `95% CI: ${formatConfidenceInterval(stats.cpCI)}`;
                document.getElementById('overall_cpk_short').textContent = isFinite(stats.cpk) ? stats.cpk.toFixed(4) : 'N/A';
                document.getElementById('overall_cpk_short_ci').textContent = `95% CI: ${formatConfidenceInterval(stats.cpkCI)}`;
                document.getElementById('overall_cpm_short').textContent = isFinite(stats.cpm) ? stats.cpm.toFixed(4) : 'N/A';
                document.getElementById('overall_cpm_short_ci').textContent = `95% CI: ${formatConfidenceInterval(stats.cpmCI)}`;

                // Mostrar valores long-term (Process Performance)
                document.getElementById('overall_dev').textContent = isFinite(stats.sigmaOverall) ? stats.sigmaOverall.toFixed(4) : 'N/A';
                document.getElementById('overall_pp').textContent = isFinite(stats.pp) ? stats.pp.toFixed(4) : 'N/A';
                document.getElementById('overall_pp_ci').textContent = `95% CI: ${formatConfidenceInterval(stats.ppCI)}`;
                document.getElementById('overall_ppk').textContent = isFinite(stats.ppk) ? stats.ppk.toFixed(4) : 'N/A';
                document.getElementById('overall_ppk_ci').textContent = `95% CI: ${formatConfidenceInterval(stats.ppkCI)}`;

                // Mostrar defectos usando long-term
                document.getElementById('overall_failures').textContent = stats.failures_ppm_lt.toFixed(2);
                document.getElementById('overall_defective').textContent = stats.defective_percentage_lt.toFixed(4);

                document.getElementById('overall_shapiro').innerHTML = formatNormalityResult(stats.shapiro);
                document.getElementById('overall_kolmogorov').innerHTML = formatNormalityResult(stats.kolmogorov);
                document.getElementById('overall_anderson').innerHTML = formatNormalityResult(stats.anderson);

                plotOverallChart(stats.mean, stats.sigmaOverall, parseFloat(document.getElementById('lsl').value),
                    parseFloat(document.getElementById('usl').value), overallData);
                createOverallControlChart(stats);
                createQQPlot(overallData, 'overallQQChartCanvas', 'Overall Q-Q Plot');

                // Mostrar el contenedor del gráfico Q-Q
                document.getElementById('overallQQChartContainer').style.display = 'block';
            }

            function formatNormalityResult(test) {
                if (!test || test.result === 'N/A') return '<span>N/A</span>';
                const resultClass = test.result === 'Pass' ? 'pass' : 'fail';
                const pVal = test.pValue ? `(p=${test.pValue.toFixed(4)})` : (test.criticalValue ? `(crit=${test.criticalValue.toFixed(4)})` : '');
                return `${test.statistic.toFixed(4)} ${pVal} <span class="${resultClass}">${test.result}</span>`;
            }

            function generateHistogramData(data) {
                const min = Math.min.apply(null, data);
                const max = Math.max.apply(null, data);
                const numBins = Math.ceil(Math.sqrt(data.length));
                // Manejo robusto de binWidth
                const binWidth = (max - min) > 0 ? (max - min) / numBins : Math.max(0.1, min * 0.01);

                let bins = Array(numBins).fill(0);
                let labels = [];
                for (let i = 0; i < numBins; i++) {
                    labels.push(min + i * binWidth + binWidth / 2);
                }

                data.forEach(function (val) {
                    let binIndex = binWidth > 0 ? Math.floor((val - min) / binWidth) : 0;
                    if (binIndex >= numBins) binIndex = numBins - 1;
                    if (binIndex < 0) binIndex = 0;
                    bins[binIndex]++;
                });

                return { labels: labels, bins: bins, binWidth: binWidth };
            }

            // Función mejorada para generar curva normal
            function generateNormalCurveData(data, mean, stdDev, binWidth) {
                if (stdDev === 0 || data.length === 0) return [];

                // Si binWidth es 0 o muy pequeño, calcular uno adecuado
                const effectiveBinWidth = binWidth > 0 ? binWidth : Math.max(0.1, (Math.max(...data) - Math.min(...data)) / 10);
                const scaleFactor = data.length * effectiveBinWidth;

                if (scaleFactor === 0) return [];

                const curvePoints = [];

                // Mejora en el cálculo del rango para incluir la dispersión de los datos
                const dataRange = Math.max(...data) - Math.min(...data);
                const stdDevRange = 4.5 * stdDev;
                const curveMin = Math.min(mean - stdDevRange, Math.min(...data) - 0.1 * dataRange);
                const curveMax = Math.max(mean + stdDevRange, Math.max(...data) + 0.1 * dataRange);

                const numCurvePoints = 101;
                const curveStep = (curveMax - curveMin) / (numCurvePoints - 1);

                for (let i = 0; i < numCurvePoints; i++) {
                    const x = curveMin + i * curveStep;
                    const y = (1 / (stdDev * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * Math.pow((x - mean) / stdDev, 2));
                    curvePoints.push({ x: x, y: y * scaleFactor });
                }
                return curvePoints;
            }

            // ====================================================================
            // FUNCIÓN PARA GRÁFICO Q-Q PLOT
            // ====================================================================

            function createQQPlot(data, canvasId, title) {
                if (chartInstances[canvasId === 'qqChartCanvas' ? 'qqChart' : 'overallQQChart']) {
                    chartInstances[canvasId === 'qqChartCanvas' ? 'qqChart' : 'overallQQChart'].destroy();
                }

                const sortedData = data.slice().sort((a, b) => a - b);
                const n = sortedData.length;

                // Calcular cuantiles teóricos
                const theoreticalQuantiles = [];
                for (let i = 0; i < n; i++) {
                    // Usar la fórmula de Blom para posiciones de trazado
                    const p = (i + 1 - 0.375) / (n + 0.25);
                    theoreticalQuantiles.push(normalQuantile(p));
                }

                // Calcular media y desviación estándar para la línea de referencia
                const mean = sortedData.reduce((a, b) => a + b, 0) / n;
                const stdDev = Math.sqrt(sortedData.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / (n - 1));

                // Calcular puntos para la línea de referencia (y = mean + stdDev * x)
                const minTheoretical = Math.min(...theoreticalQuantiles);
                const maxTheoretical = Math.max(...theoreticalQuantiles);
                const referenceLine = [
                    { x: minTheoretical, y: mean + stdDev * minTheoretical },
                    { x: maxTheoretical, y: mean + stdDev * maxTheoretical }
                ];

                const ctx = document.getElementById(canvasId).getContext('2d');
                const chart = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: [
                            {
                                label: 'Data Points',
                                data: theoreticalQuantiles.map((x, i) => ({ x, y: sortedData[i] })),
                                backgroundColor: 'rgba(52, 152, 219, 0.7)',
                                borderColor: 'rgba(52, 152, 219, 1)',
                                pointRadius: 4,
                                pointHoverRadius: 6
                            },
                            {
                                label: 'Reference Line',
                                data: referenceLine,
                                type: 'line',
                                borderColor: 'rgba(231, 76, 60, 1)',
                                borderWidth: 2,
                                fill: false,
                                pointRadius: 0,
                                showLine: true,
                                tension: 0
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: title,
                                font: { size: 16 }
                            },
                            legend: {
                                position: 'bottom'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function (context) {
                                        if (context.dataset.label === 'Data Points') {
                                            return `Theoretical: ${context.parsed.x.toFixed(4)}, Sample: ${context.parsed.y.toFixed(4)}`;
                                        }
                                        return context.dataset.label;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Theoretical Quantiles'
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.1)'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Sample Quantiles'
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.1)'
                                }
                            }
                        }
                    }
                });

                // Guardar la instancia del gráfico
                if (canvasId === 'qqChartCanvas') {
                    chartInstances.qqChart = chart;
                } else {
                    chartInstances.overallQQChart = chart;
                }

                return chart;
            }

            function plotChart(mean, deviation, lsl, usl, data, index) {
                if (chartInstances.cpkChart) chartInstances.cpkChart.destroy();

                const histogramData = generateHistogramData(data);
                const curvePoints = generateNormalCurveData(data, mean, deviation, histogramData.binWidth);

                const canvas = document.getElementById("cpkChartCanvas").getContext("2d");

                const processLowerLimit = mean - 3 * deviation;
                const processUpperLimit = mean + 3 * deviation;

                chartInstances.cpkChart = new Chart(canvas, {
                    type: 'bar',
                    data: {
                        labels: histogramData.labels,
                        datasets: [
                            {
                                label: 'Frequency',
                                data: histogramData.bins,
                                type: 'bar',
                                backgroundColor: 'rgba(52, 152, 219, 0.6)',
                                borderColor: 'rgba(52, 152, 219, 1)',
                                borderWidth: 1,
                                borderRadius: 2
                            },
                            {
                                label: 'Normal Curve',
                                data: curvePoints,
                                type: 'line',
                                borderColor: 'rgba(44, 62, 80, 1)',
                                backgroundColor: 'transparent',
                                pointRadius: 0,
                                borderWidth: 2,
                                fill: false,
                                tension: 0.1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: { display: true, text: 'Value' },
                                offset: true
                            },
                            y: {
                                beginAtZero: true,
                                title: { display: true, text: 'Frequency' }
                            }
                        },
                        plugins: {
                            legend: { display: false },
                            title: {
                                display: true,
                                text: 'Process Distribution Frequency Plot - Dataset #' + (index + 1)
                            },
                            annotation: {
                                annotations: {
                                    lsl: {
                                        type: 'line',
                                        scaleID: 'x',
                                        value: lsl,
                                        borderColor: '#e74c3c',
                                        borderWidth: 2.5,
                                        label: {
                                            enabled: true,
                                            content: 'LSL: ' + lsl,
                                            backgroundColor: '#e74c3c',
                                            color: 'white',
                                            position: 'start'
                                        }
                                    },
                                    usl: {
                                        type: 'line',
                                        scaleID: 'x',
                                        value: usl,
                                        borderColor: '#e74c3c',
                                        borderWidth: 2.5,
                                        label: {
                                            enabled: true,
                                            content: 'USL: ' + usl,
                                            backgroundColor: '#e74c3c',
                                            color: 'white',
                                            position: 'end'
                                        }
                                    },
                                    mean: {
                                        type: 'line',
                                        scaleID: 'x',
                                        value: mean,
                                        borderColor: '#333',
                                        borderWidth: 2,
                                        borderDash: [6, 6],
                                        label: {
                                            enabled: true,
                                            content: 'Mean: ' + mean.toFixed(2),
                                            backgroundColor: '#333',
                                            color: 'white',
                                            position: 'start'
                                        }
                                    },
                                    processLower: {
                                        type: 'line',
                                        scaleID: 'x',
                                        value: processLowerLimit,
                                        borderColor: '#3498db',
                                        borderWidth: 2,
                                        borderDash: [],
                                        label: {
                                            enabled: true,
                                            content: '-3σ',
                                            backgroundColor: '#3498db',
                                            color: 'white',
                                            position: 'start'
                                        }
                                    },
                                    processUpper: {
                                        type: 'line',
                                        scaleID: 'x',
                                        value: processUpperLimit,
                                        borderColor: '#3498db',
                                        borderWidth: 2,
                                        borderDash: [],
                                        label: {
                                            enabled: true,
                                            content: '+3σ',
                                            backgroundColor: '#3498db',
                                            color: 'white',
                                            position: 'end'
                                        }
                                    }
                                }
                            }
                        }
                    }
                });
            }

            function plotOverallChart(mean, deviation, lsl, usl, data) {
                if (chartInstances.overallChart) chartInstances.overallChart.destroy();

                const histogramData = generateHistogramData(data);
                const curvePoints = generateNormalCurveData(data, mean, deviation, histogramData.binWidth);

                const canvas = document.getElementById("overallChartCanvas").getContext("2d");

                const processLowerLimit = mean - 3 * deviation;
                const processUpperLimit = mean + 3 * deviation;

                chartInstances.overallChart = new Chart(canvas, {
                    type: 'bar',
                    data: {
                        labels: histogramData.labels,
                        datasets: [
                            {
                                label: 'Frequency',
                                data: histogramData.bins,
                                type: 'bar',
                                backgroundColor: 'rgba(52, 152, 219, 0.6)',
                                borderColor: 'rgba(52, 152, 219, 1)',
                                borderWidth: 1,
                                borderRadius: 2
                            },
                            {
                                label: 'Normal Curve',
                                data: curvePoints,
                                type: 'line',
                                borderColor: 'rgba(44, 62, 80, 1)',
                                backgroundColor: 'transparent',
                                pointRadius: 0,
                                borderWidth: 2,
                                fill: false,
                                tension: 0.1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: { display: true, text: 'Value' },
                                offset: true
                            },
                            y: {
                                beginAtZero: true,
                                title: { display: true, text: 'Frequency' }
                            }
                        },
                        plugins: {
                            legend: { display: false },
                            title: {
                                display: true,
                                text: 'Process Distribution Frequency Plot - Overall (long term)'
                            },
                            annotation: {
                                annotations: {
                                    lsl: {
                                        type: 'line',
                                        scaleID: 'x',
                                        value: lsl,
                                        borderColor: '#e74c3c',
                                        borderWidth: 2.5,
                                        label: {
                                            enabled: true,
                                            content: 'LSL: ' + lsl,
                                            backgroundColor: '#e74c3c',
                                            color: 'white',
                                            position: 'start'
                                        }
                                    },
                                    usl: {
                                        type: 'line',
                                        scaleID: 'x',
                                        value: usl,
                                        borderColor: '#e74c3c',
                                        borderWidth: 2.5,
                                        label: {
                                            enabled: true,
                                            content: 'USL: ' + usl,
                                            backgroundColor: '#e74c3c',
                                            color: 'white',
                                            position: 'end'
                                        }
                                    },
                                    mean: {
                                        type: 'line',
                                        scaleID: 'x',
                                        value: mean,
                                        borderColor: '#333',
                                        borderWidth: 2,
                                        borderDash: [6, 6],
                                        label: {
                                            enabled: true,
                                            content: 'Mean: ' + mean.toFixed(2),
                                            backgroundColor: '#333',
                                            color: 'white',
                                            position: 'start'
                                        }
                                    },
                                    processLower: {
                                        type: 'line',
                                        scaleID: 'x',
                                        value: processLowerLimit,
                                        borderColor: '#3498db',
                                        borderWidth: 2,
                                        borderDash: [],
                                        label: {
                                            enabled: true,
                                            content: '-3σ',
                                            backgroundColor: '#3498db',
                                            color: 'white',
                                            position: 'start'
                                        }
                                    },
                                    processUpper: {
                                        type: 'line',
                                        scaleID: 'x',
                                        value: processUpperLimit,
                                        borderColor: '#3498db',
                                        borderWidth: 2,
                                        borderDash: [],
                                        label: {
                                            enabled: true,
                                            content: '+3σ',
                                            backgroundColor: '#3498db',
                                            color: 'white',
                                            position: 'end'
                                        }
                                    }
                                }
                            }
                        }
                    }
                });
            }

            function createControlChart(dataset, index) {
                if (chartInstances.controlChart) chartInstances.controlChart.destroy();
                const ctx = document.getElementById('controlChartCanvas').getContext('2d');
                const measurements = dataset.measurements;
                const mean = dataset.mean;
                const sigmaWithin = dataset.sigmaWithin;
                const ucl = mean + 3 * sigmaWithin;
                const lcl = mean - 3 * sigmaWithin;

                chartInstances.controlChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: measurements.map(function (_, i) { return i + 1; }),
                        datasets: [
                            {
                                label: 'Measurements',
                                data: measurements,
                                borderColor: '#3498db',
                                borderWidth: 2,
                                pointRadius: 3,
                                fill: false
                            },
                            {
                                label: 'UCL',
                                data: Array(measurements.length).fill(ucl),
                                borderColor: '#e74c3c',
                                borderWidth: 2,
                                pointRadius: 0,
                                fill: false,
                                borderDash: [5, 5]
                            },
                            {
                                label: 'Mean',
                                data: Array(measurements.length).fill(mean),
                                borderColor: '#1abc9c',
                                borderWidth: 2,
                                pointRadius: 0,
                                fill: false
                            },
                            {
                                data: Array(measurements.length).fill(lcl),
                                borderColor: '#e74c3c',
                                borderWidth: 2,
                                pointRadius: 0,
                                fill: false,
                                borderDash: [5, 5]
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'I-Chart - Dataset #' + (index + 1),
                                font: { size: 16 }
                            },
                            legend: { position: 'bottom' }
                        },
                        scales: {
                            x: { title: { display: true, text: 'Observation' } },
                            y: { title: { display: true, text: 'Value' } }
                        }
                    }
                });
            }

            function createOverallControlChart(stats) {
                if (chartInstances.overallControlChart) chartInstances.overallControlChart.destroy();
                const ctx = document.getElementById('overallControlChartCanvas').getContext('2d');
                const mean = stats.mean;
                const sigmaOverall = stats.sigmaOverall;
                const ucl = mean + 3 * sigmaOverall;
                const lcl = mean - 3 * sigmaOverall;

                chartInstances.overallControlChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: overallData.map(function (_, i) { return i + 1; }),
                        datasets: [
                            {
                                label: 'Measurements',
                                data: overallData,
                                borderColor: '#3498db',
                                borderWidth: 1,
                                pointRadius: 2,
                                fill: false
                            },
                            {
                                label: 'UCL',
                                data: Array(overallData.length).fill(ucl),
                                borderColor: '#e74c3c',
                                borderWidth: 2,
                                pointRadius: 0,
                                fill: false,
                                borderDash: [5, 5]
                            },
                            {
                                label: 'Mean',
                                data: Array(overallData.length).fill(mean),
                                borderColor: '#1abc9c',
                                borderWidth: 2,
                                pointRadius: 0,
                                fill: false
                            },
                            {
                                data: Array(overallData.length).fill(lcl),
                                borderColor: '#e74c3c',
                                borderWidth: 2,
                                pointRadius: 0,
                                fill: false,
                                borderDash: [5, 5]
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Overall I-Chart',
                                font: { size: 16 }
                            },
                            legend: { position: 'bottom' }
                        },
                        scales: {
                            x: { title: { display: true, text: 'Observation' } },
                            y: { title: { display: true, text: 'Value' } }
                        }
                    }
                });
            }

            function updateDatasetTabs() {
                const tabsContainer = document.getElementById('datasetTabsContainer');
                tabsContainer.innerHTML = '';

                // Siempre mostrar las pestañas si hay al menos un dataset
                if (datasets.length >= 1) {
                    tabsContainer.style.display = 'flex';

                    // Añadir pestañas para cada dataset
                    datasets.forEach(function (dataset, index) {
                        const tab = document.createElement('div');
                        tab.className = 'dataset-tab' + (index === 0 ? ' active' : '');
                        tab.textContent = 'Dataset #' + dataset.id;
                        tab.addEventListener('click', function () {
                            document.querySelectorAll('.dataset-tab').forEach(t => t.classList.remove('active'));
                            tab.classList.add('active');
                            // Mostrar resultados del dataset seleccionado
                            displayResults(dataset, index);
                        });
                        tabsContainer.appendChild(tab);
                    });

                    // Añadir pestaña overall SIEMPRE que haya datos overall
                    if (overallData.length >= 2 && overallStats) {
                        const overallTab = document.createElement('div');
                        overallTab.className = 'dataset-tab overall-tab';
                        overallTab.textContent = 'Overall Results';
                        overallTab.addEventListener('click', function () {
                            document.querySelectorAll('.dataset-tab').forEach(t => t.classList.remove('active'));
                            overallTab.classList.add('active');
                            // Mostrar resultados overall
                            displayOverallResults(overallStats);
                        });
                        tabsContainer.appendChild(overallTab);
                    }
                } else {
                    tabsContainer.style.display = 'none';
                }
            }

            function addNewDataset() {
                currentDatasetId++;
                const newDatasetEl = document.createElement('div');
                newDatasetEl.className = 'dataset-container';
                newDatasetEl.dataset.id = currentDatasetId;
                newDatasetEl.innerHTML = '<div class="dataset-header"><span class="dataset-title">Measurements (Dataset #' + currentDatasetId + ')</span><button type="button" class="remove-dataset-btn"><i class="fas fa-times"></i> Remove</button></div><textarea class="measurements-input" rows="1"></textarea>';
                document.getElementById('datasetsContainer').appendChild(newDatasetEl);
                const removeBtn = newDatasetEl.querySelector('.remove-dataset-btn');
                removeBtn.addEventListener('click', function () {
                    if (document.querySelectorAll('.dataset-container').length > 1) {
                        newDatasetEl.remove();
                    }
                });
                // Show remove buttons if there's more than one dataset
                document.querySelectorAll('.remove-dataset-btn').forEach(function (btn) {
                    btn.style.display = 'block';
                });
            }

            function fillExampleData() {
                const currentExample = exampleDataSetsCollection[exampleIndex];

                // Advance to the next example set
                exampleIndex = (exampleIndex + 1) % exampleDataSetsCollection.length;

                const dsContainer = document.getElementById('datasetsContainer');
                dsContainer.innerHTML = '';
                currentDatasetId = 0;

                document.getElementById('lsl').value = currentExample.lsl;
                document.getElementById('usl').value = currentExample.usl;
                document.getElementById('target').value = currentExample.target;

                currentExample.datasets.forEach(function (ex) {
                    currentDatasetId++;
                    const newDatasetEl = document.createElement('div');
                    newDatasetEl.className = 'dataset-container';
                    newDatasetEl.dataset.id = currentDatasetId;
                    newDatasetEl.innerHTML = '<div class="dataset-header"><span class="dataset-title">Measurements (Dataset #' + currentDatasetId + ')</span><button type="button" class="remove-dataset-btn"><i class="fas fa-times"></i> Remove</button></div><textarea class="measurements-input" rows="1"></textarea>';
                    dsContainer.appendChild(newDatasetEl);
                    newDatasetEl.querySelector('.measurements-input').value = ex.data.join(', ');
                    newDatasetEl.querySelector('.remove-dataset-btn').addEventListener('click', function () {
                        if (document.querySelectorAll('.dataset-container').length > 1) {
                            newDatasetEl.remove();
                        }
                    });
                });

                // Show remove buttons since there are multiple datasets
                document.querySelectorAll('.remove-dataset-btn').forEach(function (btn) {
                    btn.style.display = 'block';
                });
            }

            function resetFormData() {
                document.getElementById('cpkForm').reset();
                const dsContainer = document.getElementById('datasetsContainer');
                dsContainer.innerHTML = '';
                currentDatasetId = 1;
                overallStats = null; // Limpiar overallStats al resetear

                // Crear primer dataset directamente
                const newDatasetEl = document.createElement('div');
                newDatasetEl.className = 'dataset-container';
                newDatasetEl.dataset.id = currentDatasetId;
                newDatasetEl.innerHTML = '<div class="dataset-header"><span class="dataset-title">Measurements (Dataset #' + currentDatasetId + ')</span><button type="button" class="remove-dataset-btn" style="display:none;"><i class="fas fa-times"></i> Remove</button></div><textarea class="measurements-input" rows="1" placeholder="Enter values or click \'Fill Example\'" required></textarea>';
                dsContainer.appendChild(newDatasetEl);

                // Añadir el listener al botón de remover, aunque esté oculto
                const removeBtn = newDatasetEl.querySelector('.remove-dataset-btn');
                removeBtn.addEventListener('click', function () {
                    if (document.querySelectorAll('.dataset-container').length > 1) {
                        newDatasetEl.remove();
                    }
                });

                // Ocultar contenedores de resultados
                document.getElementById('dataset-results-wrapper').classList.remove('active');
                document.getElementById('overall-results-wrapper').classList.remove('active');
                document.getElementById('short-term-charts-wrapper').style.display = 'none';
                document.getElementById('long-term-charts-wrapper').style.display = 'none';
                document.getElementById('datasetTabsContainer').style.display = 'none';
                document.getElementById('qqChartContainer').style.display = 'none';
                document.getElementById('overallQQChartContainer').style.display = 'none';

                // Resetear los nuevos valores overall
                document.getElementById('overall_cp_short').textContent = '-';
                document.getElementById('overall_cpk_short').textContent = '-';
                document.getElementById('overall_cpm_short').textContent = '-';
                document.getElementById('overall_dev_short').textContent = '-';

                // Resetear intervalos de confianza
                document.getElementById('cp_ci').textContent = '95% CI: -';
                document.getElementById('cpk_ci').textContent = '95% CI: -';
                document.getElementById('cpm_ci').textContent = '95% CI: -';
                document.getElementById('overall_cp_short_ci').textContent = '95% CI: -';
                document.getElementById('overall_cpk_short_ci').textContent = '95% CI: -';
                document.getElementById('overall_cpm_short_ci').textContent = '95% CI: -';
                document.getElementById('overall_pp_ci').textContent = '95% CI: -';
                document.getElementById('overall_ppk_ci').textContent = '95% CI: -';

                document.getElementById('exportBtn').disabled = true;

                // Resetear también los gráficos
                Object.values(chartInstances).forEach(chart => {
                    if (chart) chart.destroy();
                });
                chartInstances = {
                    cpkChart: null,
                    controlChart: null,
                    overallChart: null,
                    overallControlChart: null,
                    qqChart: null,
                    overallQQChart: null
                };
            }

            function exportToExcel() {
                if (datasets.length === 0) {
                    alert('No hay datos para exportar. Por favor, realiza un cálculo primero.');
                    return;
                }

                const wb = XLSX.utils.book_new();

                const summaryData = [
                    ["Capability Index Analysis Summary"],
                    [],
                    ["LSL:", document.getElementById('lsl').value],
                    ["USL:", document.getElementById('usl').value],
                    ["Target:", document.getElementById('target').value],
                    [],
                    ["Overall (Long-Term) Results"],
                    ["Total Points", overallData.length],
                    ["Overall Mean", overallStats.mean.toFixed(4)],
                    ["Overall Std Dev (long-term)", overallStats.sigmaOverall.toFixed(4)],
                    ["Pp", overallStats.pp.toFixed(4)],
                    ["Pp 95% CI Lower", formatConfidenceInterval(overallStats.ppCI).split('[')[1]?.split(',')[0] || 'N/A'],
                    ["Pp 95% CI Upper", formatConfidenceInterval(overallStats.ppCI).split(',')[1]?.split(']')[0] || 'N/A'],
                    ["Ppk", overallStats.ppk.toFixed(4)],
                    ["Ppk 95% CI Lower", formatConfidenceInterval(overallStats.ppkCI).split('[')[1]?.split(',')[0] || 'N/A'],
                    ["Ppk 95% CI Upper", formatConfidenceInterval(overallStats.ppkCI).split(',')[1]?.split(']')[0] || 'N/A'],
                    ["Expected Failures (ppm)", overallStats.failures_ppm_lt.toFixed(2)],
                    ["Defective Parts", overallStats.defective_percentage_lt.toFixed(4)],
                    [],
                    ["Overall (Short-Term) Results"],
                    ["Overall Std Dev (short-term)", overallStats.sigmaWithin.toFixed(4)],
                    ["Cp (overall short-term)", isFinite(overallStats.cp) ? overallStats.cp.toFixed(4) : 'N/A'],
                    ["Cp 95% CI Lower", formatConfidenceInterval(overallStats.cpCI).split('[')[1]?.split(',')[0] || 'N/A'],
                    ["Cp 95% CI Upper", formatConfidenceInterval(overallStats.cpCI).split(',')[1]?.split(']')[0] || 'N/A'],
                    ["Cpk (overall short-term)", isFinite(overallStats.cpk) ? overallStats.cpk.toFixed(4) : 'N/A'],
                    ["Cpk 95% CI Lower", formatConfidenceInterval(overallStats.cpkCI).split('[')[1]?.split(',')[0] || 'N/A'],
                    ["Cpk 95% CI Upper", formatConfidenceInterval(overallStats.cpkCI).split(',')[1]?.split(']')[0] || 'N/A'],
                    ["Cpm (overall short-term)", isFinite(overallStats.cpm) ? overallStats.cpm.toFixed(4) : 'N/A'],
                    ["Cpm 95% CI Lower", formatConfidenceInterval(overallStats.cpmCI).split('[')[1]?.split(',')[0] || 'N/A'],
                    ["Cpm 95% CI Upper", formatConfidenceInterval(overallStats.cpmCI).split(',')[1]?.split(']')[0] || 'N/A'],
                    ["Expected Failures (ppm)", overallStats.failures_ppm.toFixed(2)],
                    ["Defective Parts", overallStats.defective_percentage.toFixed(4)],
                    [],
                    ["Overall Normality Tests"],
                    ["Shapiro-Wilk", overallStats.shapiro.result + ' (W=' + overallStats.shapiro.statistic.toFixed(4) + ', p=' + (overallStats.shapiro.pValue ? overallStats.shapiro.pValue.toFixed(4) : 'N/A') + ')'],
                    ["Kolmogorov-Smirnov", overallStats.kolmogorov.result + ' (D=' + overallStats.kolmogorov.statistic.toFixed(4) + ', p=' + (overallStats.kolmogorov.pValue ? overallStats.kolmogorov.pValue.toFixed(4) : 'N/A') + ')'],
                    ["Anderson-Darling", overallStats.anderson.result + ' (A²=' + overallStats.anderson.statistic.toFixed(4) + ', crit=' + (overallStats.anderson.criticalValue ? overallStats.anderson.criticalValue.toFixed(4) : 'N/A') + ')'],
                    [],
                    ["Individual Dataset Results"],
                    ["Dataset", "Mean", "Std Dev (short-term)", "Cp", "Cp 95% CI", "Cpk", "Cpk 95% CI", "Cpm", "Cpm 95% CI", "Failures (ppm)", "Defective",
                        "Shapiro-Wilk Result", "Shapiro-Wilk Statistic", "Shapiro-Wilk p-value",
                        "Kolmogorov Result", "Kolmogorov Statistic", "Kolmogorov p-value",
                        "Anderson-Darling Result", "Anderson-Darling Statistic", "Anderson-Darling Critical Value"]
                ];

                datasets.forEach(function (d) {
                    summaryData.push([
                        'Dataset #' + d.id,
                        d.mean.toFixed(4),
                        d.sigmaWithin.toFixed(4),
                        isFinite(d.cp) ? d.cp.toFixed(4) : 'N/A',
                        formatConfidenceInterval(d.cpCI),
                        isFinite(d.cpk) ? d.cpk.toFixed(4) : 'N/A',
                        formatConfidenceInterval(d.cpkCI),
                        isFinite(d.cpm) ? d.cpm.toFixed(4) : 'N/A',
                        formatConfidenceInterval(d.cpmCI),
                        d.failures_ppm.toFixed(2),
                        d.defective_percentage.toFixed(4),
                        d.shapiro.result,
                        d.shapiro.statistic.toFixed(4),
                        d.shapiro.pValue ? d.shapiro.pValue.toFixed(4) : 'N/A',
                        d.kolmogorov.result,
                        d.kolmogorov.statistic.toFixed(4),
                        d.kolmogorov.pValue ? d.kolmogorov.pValue.toFixed(4) : 'N/A',
                        d.anderson.result,
                        d.anderson.statistic.toFixed(4),
                        d.anderson.criticalValue ? d.anderson.criticalValue.toFixed(4) : 'N/A'
                    ]);
                });

                // Datos brutos por dataset
                datasets.forEach(function (d, index) {
                    const datasetData = [["Dataset #" + d.id + " - Raw Data"]];
                    d.measurements.forEach(function (point) {
                        datasetData.push([point]);
                    });
                    const wsDataset = XLSX.utils.aoa_to_sheet(datasetData);
                    XLSX.utils.book_append_sheet(wb, wsDataset, "Dataset " + (index + 1));
                });

                // Todos los datos brutos combinados
                const rawDataSheet = [["All Data Points (Combined)"]];
                overallData.forEach(function (d) {
                    rawDataSheet.push([d]);
                });
                const wsRawData = XLSX.utils.aoa_to_sheet(rawDataSheet);
                XLSX.utils.book_append_sheet(wb, wsRawData, "All Raw Data");

                const wsSummary = XLSX.utils.aoa_to_sheet(summaryData);
                XLSX.utils.book_append_sheet(wb, wsSummary, "Summary");

                XLSX.writeFile(wb, "cpk_analysis.xlsx");
            }

            // ====================================================================
            // 1. FUNCIONES AUXILIARES DE ALTA PRECISIÓN (normalCDF y normalQuantile)
            // ====================================================================

            /**
             * HIGH-PRECISION NORMAL CDF IMPLEMENTATION
             * Hart double-precision algorithm (error < 1e-12)
             */
            function normalCDF(x) {
                if (x === 0) return 0.5;

                const absX = Math.abs(x);
                if (absX > 8) {
                    return x > 0 ? 1 : 0;
                }

                // Hart algorithm (1966) - double precision
                const t = 1 / (1 + 0.2316419 * absX);
                const d = 0.3989422804014327 * Math.exp(-x * x / 2);

                const p = d * t * (0.31938153 + t * (-0.356563782 + t * (1.781477937 + t * (-1.821255978 + t * 1.330274429))));

                // p calcula la cola superior: P(Z > |x|).
                // Si x > 0, queremos 1 - P(Z > x). Si x < 0, queremos P(Z < x) = P(Z > |x|).
                return x > 0 ? 1 - p : p;
            }

            /**
             * HIGH-PRECISION NORMAL QUANTILE FUNCTION
             * Acklam's algorithm (error < 1.15e-9)
             */
            function normalQuantile(p) {
                if (p <= 0 || p >= 1) {
                    return p === 0 ? -Infinity : p === 1 ? Infinity : NaN;
                }

                const a1 = -3.969683028665376e+01;
                const a2 = 2.209460984245205e+02;
                const a3 = -2.759285104469687e+02;
                const a4 = 1.383577518672690e+02;
                const a5 = -3.066479806614716e+01;
                const a6 = 2.506628277459239e+00;

                const b1 = -5.447609879822406e+01;
                const b2 = 1.615858368580409e+02;
                const b3 = -1.556989798598866e+02;
                const b4 = 6.680131188771972e+01;
                const b5 = -1.328068155288572e+01;

                const c1 = -7.784894002430293e-03;
                const c2 = -3.223964580411365e-01;
                const c3 = -2.400758277161838e+00;
                const c4 = -2.549732539343734e+00;
                const c5 = 4.374664141464968e+00;
                const c6 = 2.938163982698783e+00;

                const d1 = 7.784695709041462e-03;
                const d2 = 3.224671290700398e-01;
                const d3 = 2.445134137142996e+00;
                const d4 = 3.754408661907416e+00;

                let q, r;

                if (p < 0.02425) {
                    // Rational approximation for lower region
                    q = Math.sqrt(-2 * Math.log(p));
                    return (((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) /
                        ((((d1 * q + d2) * q + d3) * q + d4) * q + 1);
                } else if (p > 0.97575) {
                    // Rational approximation for upper region
                    q = Math.sqrt(-2 * Math.log(1 - p));
                    return -(((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) /
                        ((((d1 * q + d2) * q + d3) * q + d4) * q + 1);
                } else {
                    // Rational approximation for central region
                    q = p - 0.5;
                    r = q * q;
                    return (((((a1 * r + a2) * r + a3) * r + a4) * r + a5) * r + a6) * q /
                        (((((b1 * r + b2) * r + b3) * r + b4) * r + b5) * r + 1);
                }
            }


            // ====================================================================
            // 2. SHAPIRO-WILK TEST - IMPLEMENTACIÓN CORREGIDA
            // ====================================================================

            /**
             * SHAPIRO-WILK TEST IMPLEMENTATION - Versión corregida
             * Basado en el algoritmo de Royston para n <= 5000
             */
            function shapiroWilkTest(data) {
                const n = data.length;

                // Validación de parámetros
                if (n < 3) {
                    return { statistic: NaN, pValue: NaN, result: 'N/A', message: 'Sample size too small (n < 3 required)' };
                }
                if (n > 5000) {
                    return { statistic: NaN, pValue: NaN, result: 'N/A', message: 'Sample size too large (n > 5000 not supported)' };
                }

                // Paso 1: Verificar si todos los valores son iguales
                const allEqual = data.every(val => val === data[0]);
                if (allEqual) {
                    return {
                        statistic: 1.0,
                        pValue: 1.0,
                        result: 'Pass',
                        message: 'All values are identical (perfect correlation with normal distribution)'
                    };
                }

                // Paso 2: Ordenar datos
                const sorted = data.slice().sort(function (a, b) { return a - b; });

                // Paso 3: Calcular la media
                const mean = sorted.reduce(function (a, b) { return a + b; }, 0) / n;

                // Paso 4: Calcular varianza
                let variance = 0;
                for (let i = 0; i < n; i++) {
                    variance += Math.pow(sorted[i] - mean, 2);
                }
                variance = variance / (n - 1);

                // NUEVO: Verificar si la varianza es extremadamente pequeña
                // Si la varianza es < 1e-10, considerarla como varianza cero para propósitos de la prueba
                if (variance < 1e-10) {
                    // Para datos con variación mínima, usar una aproximación simplificada
                    // En este caso, los datos son prácticamente constantes, lo que es "perfectamente normal"
                    return {
                        statistic: 1.0,
                        pValue: 1.0,
                        result: 'Pass',
                        message: 'Variance too small (< 1e-10), data appears normal'
                    };
                }

                // Paso 5: Calcular los coeficientes de Shapiro-Wilk usando aproximación
                const a = calculateShapiroWilkCoefficients(n);

                // Paso 6: Calcular estadístico W con protección numérica
                const W = calculateShapiroWStatisticRobust(sorted, a, n, mean, variance);

                // Paso 7: Calcular p-value usando transformación de Royston
                const pValue = calculateShapiroWilkPValue(W, n);

                return {
                    statistic: W,
                    pValue: pValue,
                    result: pValue > 0.05 ? 'Pass' : 'Fail',
                    message: pValue > 0.05 ? 'Data appears normal' : 'Data significantly deviates from normality'
                };
            }

            function calculateShapiroWStatisticRobust(sorted, a, n, mean, variance) {
                const k = Math.floor(n / 2);

                // Calcular el numerador con protección contra underflow
                let numerator = 0;
                for (let i = 0; i < k; i++) {
                    const diff = sorted[n - 1 - i] - sorted[i];
                    // Si la diferencia es muy pequeña pero no cero, usar un valor mínimo
                    if (Math.abs(diff) < 1e-15 && diff !== 0) {
                        numerator += a[i] * 1e-15;
                    } else if (i < a.length) {
                        numerator += a[i] * diff;
                    }
                }

                // Asegurarse de que el numerador sea positivo
                numerator = Math.max(1e-15, Math.abs(numerator));
                numerator = Math.pow(numerator, 2);

                // Usar la varianza precalculada como denominador
                const denominator = variance * (n - 1);

                // Evitar división por cero
                if (denominator === 0 || denominator < 1e-15) {
                    return 1.0; // Datos perfectamente correlacionados
                }

                const W = numerator / denominator;

                // Asegurar que W esté en el rango [0, 1]
                return Math.max(0, Math.min(1, W));
            }

            function calculateShapiroWilkCoefficients(n) {
                // Para n <= 50, usar aproximación con cuantiles normales
                // Para n > 50, usar la aproximación estándar
                const a = new Array(Math.floor(n / 2));

                if (n <= 50) {
                    // Usar aproximación basada en cuantiles normales
                    for (let i = 0; i < a.length; i++) {
                        const u = (i + 1 - 0.375) / (n + 0.25);
                        a[i] = normalQuantile(u);
                    }

                    // Normalizar los coeficientes
                    const norm = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
                    for (let i = 0; i < a.length; i++) {
                        a[i] = a[i] / norm;
                    }
                } else {
                    // Para n grande, usar aproximación más simple pero efectiva
                    for (let i = 0; i < a.length; i++) {
                        const u = (i + 1 - 0.375) / (n + 0.25);
                        a[i] = normalQuantile(u);
                    }

                    // Ajuste para n grande
                    const scale = Math.sqrt(n);
                    for (let i = 0; i < a.length; i++) {
                        a[i] = a[i] / scale;
                    }
                }

                return a;
            }

            function calculateShapiroWilkPValue(W, n) {
                // Transformación de Royston mejorada
                if (n <= 11) {
                    const gamma = 0.459 * n - 2.273;
                    const sigma = Math.exp(0.5440 - 0.39978 * n + 0.025054 * Math.pow(n, 2) - 0.0006714 * Math.pow(n, 3));
                    const y = Math.log(1 - W);
                    const z = (y - gamma) / sigma;
                    return 1 - normalCDF(z);
                } else {
                    // Para n > 11
                    const u = Math.log(n);
                    const mu = -1.5861 - 0.31082 * u - 0.083751 * u * u + 0.0038915 * u * u * u;
                    const sigma = Math.exp(-0.4803 - 0.082676 * u + 0.0030302 * u * u);

                    // Manejar casos donde W está cerca de 1
                    const safeW = Math.min(0.999999, Math.max(W, 0.000001));
                    const y = Math.log(1 - safeW);
                    const z = (y - mu) / sigma;

                    return 1 - normalCDF(z);
                }
            }


            // ====================================================================
            // 3. KOLMOGOROV-SMIRNOV TEST - MEJORADO
            // ====================================================================

            function kolmogorovSmirnovTest(data) {
                const n = data.length;

                if (n < 5) {
                    return { statistic: NaN, pValue: NaN, result: 'N/A', message: 'Sample size too small (n < 5 required)' };
                }

                // Estandarizar datos
                const sorted = data.slice().sort(function (a, b) { return a - b; });
                const mean = sorted.reduce(function (a, b) { return a + b; }, 0) / n;
                const stdDev = Math.sqrt(sorted.reduce(function (a, b) { return a + Math.pow(b - mean, 2); }, 0) / (n - 1));

                if (stdDev === 0) {
                    return {
                        statistic: 0,
                        pValue: 1.0,
                        result: 'Pass',
                        message: 'All values are identical (perfect fit to normal distribution)'
                    };
                }

                // Calcular estadístico D
                let Dplus = 0;
                let Dminus = 0;

                for (let i = 0; i < n; i++) {
                    const Fn = (i + 1) / n;
                    const F = normalCDF((sorted[i] - mean) / stdDev);
                    const Fn_prev = i / n;

                    Dplus = Math.max(Dplus, Fn - F);
                    Dminus = Math.max(Dminus, F - Fn_prev);
                }

                const D = Math.max(Dplus, Dminus);

                // Calcular p-value usando la fórmula de Stephens
                const pValue = calculateKSPValue(D, n);

                return {
                    statistic: D,
                    pValue: pValue,
                    result: pValue > 0.05 ? 'Pass' : 'Fail',
                    message: pValue > 0.05 ? 'Data appears normal' : 'Data significantly deviates from normality'
                };
            }

            function calculateKSPValue(D, n) {
                // Fórmula de Stephens para p-value
                if (n <= 100) {
                    const D_corrected = D * (Math.sqrt(n) + 0.12 + 0.11 / Math.sqrt(n));
                    const term = -2 * D_corrected * D_corrected;
                    return Math.max(0, Math.min(1, 1 - Math.exp(term)));
                } else {
                    // Para n grande
                    const K = D * Math.sqrt(n);
                    let sum = 0;
                    for (let k = 1; k <= 100; k++) {
                        const term = Math.pow(-1, k - 1) * Math.exp(-2 * k * k * K * K);
                        sum += term;
                        if (Math.abs(term) < 1e-10) break;
                    }
                    return Math.max(0, Math.min(1, 2 * sum));
                }
            }


            // ====================================================================
            // 4. ANDERSON-DARLING TEST
            // ====================================================================

            /**
             * PROFESSIONAL ANDERSON-DARLING TEST IMPLEMENTATION (Stephens, 1974)
             */
            function andersonDarlingTest(data) {
                const n = data.length;

                if (n < 8) {
                    return { statistic: NaN, criticalValue: NaN, result: 'N/A', message: 'Sample size too small (n < 8 required)' };
                }

                // Paso 1: Estandarizar datos
                const sorted = data.slice().sort(function (a, b) { return a - b; });
                const mean = sorted.reduce(function (a, b) { return a + b; }, 0) / n;
                const variance = sorted.reduce(function (a, b) { return a + Math.pow(b - mean, 2); }, 0) / (n - 1);
                const stdDev = Math.sqrt(variance);

                if (stdDev === 0) {
                    return { statistic: 0, criticalValue: 0, pValue: 1.0, result: 'Pass', message: 'All values identical (perfect fit to normal distribution)' };
                }

                // Paso 2: Calcular estadístico A²
                let A2 = calculateAndersonDarlingStatistic(sorted, mean, stdDev, n);

                // Paso 3: Aplicar corrección para tamaño de muestra
                const A2_corrected = applyAndersonDarlingCorrection(A2, n);

                // Paso 4: Obtener valor crítico y p-value aproximado
                const criticalValue = getAndersonDarlingCriticalValue(n);
                const pValue = estimateAndersonDarlingPValue(A2_corrected, n);

                return {
                    statistic: A2_corrected,
                    criticalValue: criticalValue,
                    pValue: pValue,
                    result: A2_corrected <= criticalValue ? 'Pass' : 'Fail',
                    message: A2_corrected <= criticalValue ? 'Data appears normal' : 'Data significantly deviates from normality'
                };
            }

            function calculateAndersonDarlingStatistic(sorted, mean, stdDev, n) {
                let sum = 0;
                const epsilon = 1e-10; // CÓDIGO DE ROBUSTEZ: Previene Math.log(0) o Math.log(1)

                for (let i = 0; i < n; i++) {
                    const z = (sorted[i] - mean) / stdDev;
                    const F = normalCDF(z);

                    // Asegurar que F esté entre un valor muy pequeño (epsilon) y 1 - epsilon
                    const F_robust = Math.max(epsilon, Math.min(1 - epsilon, F));

                    const logF = Math.log(F_robust);
                    const log1mF = Math.log(1 - F_robust);

                    const term1 = (2 * i + 1) * logF;
                    const term2 = (2 * (n - i) - 1) * log1mF;

                    sum += term1 + term2;
                }

                return -n - sum / n;
            }

            function applyAndersonDarlingCorrection(A2, n) {
                // Corrección de Stephens (1974) para estadístico A²
                if (n >= 20) {
                    return A2 * (1 + 0.75 / n + 2.25 / (n * n));
                } else {
                    // Corrección más simple para muestras pequeñas
                    return A2 * (1 + 0.3 / n);
                }
            }

            function getAndersonDarlingCriticalValue(n) {
                // Valores críticos de D'Agostino (1986) para alpha = 0.05
                const criticalValues = {
                    8: 0.736, 9: 0.768, 10: 0.805, 11: 0.839, 12: 0.870,
                    13: 0.900, 14: 0.928, 15: 0.954, 16: 0.979, 17: 1.002,
                    18: 1.024, 19: 1.045, 20: 1.065, 25: 1.173, 30: 1.266,
                    35: 1.349, 40: 1.424, 45: 1.493, 50: 1.557, 60: 1.673,
                    70: 1.777, 80: 1.872, 90: 1.960, 100: 2.042,
                    150: 2.381, 200: 2.626, 300: 2.998, 400: 3.283,
                    500: 3.516, 1000: 4.318
                };

                // Interpolación para valores intermedios
                const sizes = Object.keys(criticalValues).map(Number).sort(function (a, b) { return a - b; });

                if (n <= sizes[0]) return criticalValues[sizes[0]];
                if (n >= sizes[sizes.length - 1]) return criticalValues[sizes[sizes.length - 1]];

                for (let i = 0; i < sizes.length - 1; i++) {
                    if (n >= sizes[i] && n <= sizes[i + 1]) {
                        const t = (n - sizes[i]) / (sizes[i + 1] - sizes[i]);
                        return criticalValues[sizes[i]] * (1 - t) + criticalValues[sizes[i + 1]] * t;
                    }
                }

                return 0.752; // Valor por defecto si falla la lógica
            }

            function estimateAndersonDarlingPValue(A2, n) {
                // Estimación aproximada del p-value (útil si no se usa una función CDF específica)
                if (A2 <= 0.2) return 0.99;
                if (A2 <= 0.5) return 0.90;
                if (A2 <= 0.8) return 0.70;
                if (A2 <= 1.0) return 0.50;
                if (A2 <= 1.5) return 0.20;
                if (A2 <= 2.0) return 0.10;
                if (A2 <= 2.5) return 0.05;
                if (A2 <= 3.0) return 0.025;
                if (A2 <= 3.5) return 0.01;
                return 0.001;
            }

        });
    </script>

</body>

</html>