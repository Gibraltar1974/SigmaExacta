<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cause and Effect (Ishikawa) Diagram Generator | Sigma Exacta</title>
    <meta name="description"
        content="Free online Ishikawa (Fishbone) Diagram generator. A powerful tool for root cause analysis, helping teams brainstorm, categorize, and visualize potential causes of a problem. Ideal for quality improvement, problem-solving, and process analysis.">
    <meta name="keywords"
        content="Free software, Open source, ishikawa diagram, fishbone diagram, cause and effect diagram, root cause analysis, 6m, quality improvement tool, problem solving, process analysis, online generator, free ishikawa diagram, free fishbone diagram">

    <link rel="canonical" href="https://sigmaexacta.com/ishikawa" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;800&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="styles.css">

    <style>
        /* --- ESTILOS DEL HEADER IDÉNTICOS A INDEX.HTML --- */
        /* El CSS del Header ha sido eliminado. Se cargará desde header.html */

        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --light-color: #ecf0f1;
            --dark-color: #2c3e50;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --cause-text-color: #333;
            font-size: 16px;

            /* Category colors */
            --manpower-color: #3498db;
            --methods-color: #2ecc71;
            --machines-color: #e74c3c;
            --materials-color: #f39c12;
            --environment-color: #9b59b6;
            --measurement-color: #1abc9c;
        }

        body {
            background-color: #f5f7fa;
            font-family: 'Nunito', sans-serif;
            margin: 0;
        }

        .main-content-wrapper {
            padding: 1.25rem;
        }

        .header {
            max-width: 100%;
            /* CAMBIO: Era 1000px */
            margin: 0 auto 1.25rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #ddd;
            text-align: center;
        }

        .header h1 {
            color: var(--primary-color);
            font-size: clamp(1.5rem, 4vw, 1.8rem);
            margin: 0.5rem 0;
            font-weight: 800;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Adjusted for flex */
        .header .header-subtitle {
            font-size: 1.1rem;
            color: #7f8c8d;
            margin: 0;
            font-weight: 400;
        }

        /* NEW STYLE FOR H1 ICON */
        .h1-icon-container {
            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-size: 1.5rem;
            /* Smaller than the original 2.5rem for better H1 fit */
            width: 40px;
            /* Adjusted size */
            height: 40px;
            /* Adjusted size */
            border-radius: 8px;
            /* Square border */
            background-color: #4a90e2;
            /* Color '8' from index.html */
            margin-right: 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* END NEW STYLE */
        .content-block {
            max-width: 100%;
            /* CAMBIO: Era 1000px */
            margin: 0 auto 1.5rem;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 1.5rem;
            background-color: white;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .content-block h2 {
            font-size: 1.5em;
            margin-top: 0;
            margin-bottom: 1.25rem;
            color: var(--primary-color);
            border-bottom: 2px solid var(--secondary-color);
            padding-bottom: 0.6rem;
            font-weight: 800;
        }

        .content-block h2 .fas {
            margin-right: 0.75rem;
        }

        .content-block ol,
        .content-block ul {
            padding-left: 1.25rem;
            line-height: 1.8;
        }

        .calculation-block {
            max-width: 100%;
            /* CAMBIO: Era 1000px */
            margin: 0 auto 1.25rem;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 1.5rem;
            background-color: white;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .calculation-title {
            font-weight: 800;
            font-size: 1.2em;
            margin-bottom: 1rem;
            color: var(--primary-color);
            border-bottom: 1px solid #eee;
            padding-bottom: 0.6rem;
        }

        label,
        label.category-label {
            display: block;
            margin-bottom: 0.6rem;
            color: var(--primary-color);
            font-weight: 600;
        }

        label.category-label {
            font-size: 1.1em;
        }

        input[type="text"] {
            width: 100%;
            padding: 0.6rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
            transition: border 0.3s, box-shadow 0.3s;
            box-sizing: border-box;
            font-family: 'Nunito', sans-serif;
        }

        input[type="text"]:focus,
        button:focus-visible {
            outline: none;
            border-color: var(--secondary-color);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.3);
        }

        button {
            background-color: var(--secondary-color);
            color: white;
            padding: 0.7rem 1.25rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
            font-size: 1rem;
            transition: background-color 0.3s, box-shadow 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-family: 'Nunito', sans-serif;
            font-weight: 600;
        }

        button:hover {
            background-color: #2980b9;
        }

        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }

        .button-group {
            display: flex;
            justify-content: flex-start;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        button.success {
            background-color: var(--success-color);
        }

        button.success:hover {
            background-color: #219d55;
        }

        button.warning {
            background-color: var(--warning-color);
        }

        button.warning:hover {
            background-color: #da8c10;
        }

        .danger {
            background-color: var(--accent-color);
        }

        .danger:hover {
            background-color: #c0392b;
        }

        .diagram-controls {
            max-width: 100%;
            /* CAMBIO: Era 1000px */
            margin: 0 auto 1rem;
            text-align: right;
            display: flex;
            justify-content: flex-end;
            flex-wrap: wrap;
        }

        #ishikawaDiagramContainer {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            flex: 1;
            min-width: 300px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            position: relative;
            overflow: hidden;
            min-height: 600px;
        }

        /* CORRECCIÓN 1: Leyenda en una sola línea */
        .diagram-key {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: #f8f9fa;
            padding: 0.5rem 1rem;
            border-top: 1px solid #e0e0e0;
            border-radius: 0 0 8px 8px;
            box-sizing: border-box;
            overflow-x: auto;
        }

        .diagram-key ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-wrap: nowrap;
            justify-content: space-between;
            gap: 0.6rem 1.25rem;
            white-space: nowrap;
        }

        .diagram-key ul li {
            color: #555;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
        }

        .diagram-key ul li i {
            margin-right: 6px;
        }

        .diagram-key ul li strong {
            color: var(--dark-color);
        }

        /* FIN CORRECCIÓN 1 */
        .category-section {
            margin-bottom: 1.5rem;
            border-top: 1px solid #eee;
            padding-top: 1.25rem;
        }

        .cause-block {
            background-color: #fdfdfd;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .cause-input-wrapper {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            margin-bottom: 0.6rem;
        }

        .sub-causes-container {
            margin-left: 2rem;
            margin-top: 0.6rem;
        }

        .sub-cause-item {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            margin-bottom: 0.5rem;
        }

        .sub-sub-causes-container {
            margin-left: 2rem;
            margin-top: 0.6rem;
        }

        .sub-sub-cause-item {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            margin-bottom: 0.5rem;
        }

        .action-button {
            padding: 0;
            width: 30px;
            height: 30px;
            min-width: 30px;
            font-size: 1rem;
            line-height: 30px;
            text-align: center;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0;
        }

        .add-sub-cause-btn {
            margin-left: 0.6rem;
        }

        .add-sub-sub-cause-btn {
            margin-left: 0.6rem;
        }

        .add-cause-btn {
            margin-top: 0.6rem;
        }

        footer {
            padding: 2rem 1.25rem;
            text-align: center;
        }

        .disclaimer-note {
            margin-top: 2rem;
            padding: 0 1rem;
            font-size: 0.8rem;
            color: #777;
            max-width: 100%;
            /* CAMBIO: Era 800px */
            margin-left: auto;
            margin-right: auto;
        }

        /* New styles for SVG diagram */
        #ishikawaSvgContainer {
            width: 100%;
            height: 100%;
            min-height: 600px;
        }

        .draggable {
            cursor: move;
            user-select: none;
        }

        .draggable:hover {
            filter: drop-shadow(0 0 3px rgba(0, 0, 0, 0.3));
        }

        .category-bone {
            stroke-width: 2;
        }

        .cause-line {
            stroke-width: 1.5;
        }

        .subcause-line {
            stroke-width: 1;
        }

        .cause-text,
        .subcause-text,
        .subsubcause-text {
            font-family: 'Nunito', sans-serif;
        }

        .main-category-text {
            font-family: 'Nunito', sans-serif;
            font-weight: bold;
            text-anchor: middle;
            font-size: 14px;
        }

        .cause-text {
            font-size: 12px;
            font-weight: 600;
        }

        .subcause-text {
            font-size: 11px;
        }

        .problem-box {
            fill: var(--accent-color);
        }

        .problem-text {
            fill: white;
            font-family: 'Nunito', sans-serif;
            font-weight: bold;
            text-anchor: middle;
            font-size: 14px;
            /* Added for consistency */
        }

        @media (max-width: 768px) {
            .main-content-wrapper {
                padding: 0.75rem;
            }

            .content-block,
            .calculation-block {
                padding: 1rem;
            }

            .header h1 {
                font-size: clamp(1.4rem, 5vw, 1.8rem);
            }

            #ishikawaDiagramContainer {
                min-height: 500px;
            }

            /* CORRECCIÓN 2: Mejor visualización en móvil */
            .diagram-key ul {
                justify-content: flex-start;
                padding: 0 5px;
            }

            .diagram-key ul li {
                font-size: 0.7rem;
            }

            /* FIN CORRECCIÓN 2 */
        }
    </style>
</head>

<body>

    <div id="header-container"></div>

    <main class="main-content-wrapper">
        <header class="header">
            <h1>
                <span class="h1-icon-container"><i class="fas fa-fish"></i></span> Free Online Fishbone Cause and Effect
                (Ishikawa) Diagram
            </h1>
            <p class="header-subtitle">A Visual Tool for Root Cause Analysis</p>
        </header>

        <div class="content-block">
            <h2><i class="fas fa-question-circle"></i> What is a Cause and Effect Diagram?</h2>
            <p>The <strong>Cause and Effect Diagram</strong>, also known as a <strong>Fishbone Diagram</strong> or
                <strong>Ishikawa Diagram</strong>, is a visual tool used to explore and categorize the potential causes
                of a specific problem. Its main purpose is to structure a brainstorming session, helping teams to think
                through all possible reasons for an issue in a systematic way rather than jumping to conclusions.</p>
            <p>The diagram resembles a fish skeleton, which is where it gets its nickname:</p>
            <ul>
                <li>The <strong>"head"</strong> of the fish represents the problem or effect, which is written on the
                    right side.</li>
                <li>The <strong>"spine"</strong> is a horizontal line pointing to the head.</li>
                <li>The <strong>"bones"</strong> are diagonal lines branching off the spine, representing major
                    categories of potential causes. This tool traditionally uses the <strong>6Ms</strong> as categories,
                    which are a great starting point for any manufacturing or service process.</li>
            </ul>
        </div>

        <div class="content-block">
            <h2><i class="fas fa-history"></i> Brief History of the Ishikawa Diagram</h2>
            <p>The diagram was created by <strong>Dr. Kaoru Ishikawa</strong>, a Japanese quality control expert, in the
                1960s. As a pioneer in quality management, Dr. Ishikawa wanted to create simple, accessible tools that
                workers at all levels of an organization could use to improve processes. He believed that quality
                improvement was a continuous, company-wide effort, not just the responsibility of managers and
                engineers.</p>
            <p>The Ishikawa Diagram became one of the <strong>Seven Basic Tools of Quality</strong>. Its simplicity and
                visual nature made it extremely popular in post-war Japan's manufacturing industries and it quickly
                spread globally as a fundamental tool for problem-solving, root cause analysis, and quality improvement
                initiatives.</p>
        </div>

        <div class="content-block">
            <h2><i class="fas fa-cogs"></i> How to Use This Tool</h2>
            <ol>
                <li><strong>Define the Problem:</strong> Clearly and concisely write the problem you are investigating
                    in the "Problem Statement" field. This becomes the "head" of the fishbone.</li>
                <li><strong>Add Causes:</strong> For each of the 6M categories, click the "➕ Add Cause" button to create
                    a field for a main cause.</li>
                <li><strong>Add Sub-Causes:</strong> Within each main cause, click the `+` button to add specific
                    sub-cause fields for more detail.</li>
                <li><strong>Add Sub-Sub-Causes:</strong> Within each sub-cause, click the `+` button to add even more
                    detailed sub-sub-cause fields.</li>
                <li><strong>Generate Diagram:</strong> Click "Generate Diagram". The tool will create a visual fishbone
                    diagram based on your input.</li>
                <li><strong>Use Helper Buttons:</strong> Click "Load Example" to see a pre-filled diagram for guidance,
                    or "Reset Data" to clear all fields and start fresh.</li>
                <li><strong>Export Your Work:</strong> Once your diagram is complete, you can export it as a JPG image
                    for presentations or as an Excel file for documentation.</li>
            </ol>
        </div>


        <div class="calculation-block">
            <div class="calculation-title">Define Your Problem and Categories</div>

            <form id="ishikawaForm">
                <label for="problem"><i class="fas fa-bug"></i> <strong>Problem Statement:</strong></label>
                <input type="text" id="problem" placeholder="Example: High customer complaint rate" required />

                <div class="button-group">
                    <button type="button" id="exampleBtn" class="success"><i class="fas fa-lightbulb"></i> Load
                        Example</button>
                    <button type="button" id="resetBtn" class="warning"><i class="fas fa-redo"></i> Reset Data</button>
                </div>

                <div id="categories-container"></div>
            </form>
        </div>

        <div class="diagram-controls">
            <button type="submit" form="ishikawaForm"><i class="fas fa-project-diagram"></i> Generate Diagram</button>
            <button id="exportJpgBtn" class="success" title="Export as JPG image"><i class="fas fa-file-image"></i>
                Export as JPG</button>
            <button id="exportBtn" class="success" title="Export data to Excel"><i class="fas fa-file-excel"></i> Export
                to Excel</button>
        </div>

        <div class="content-block">
            <div id="ishikawaDiagramContainer">
                <svg id="ishikawaSvgContainer" width="100%" height="100%"></svg>
                <div class="diagram-key">
                    <ul>
                        <li><i class="fas fa-users" style="color: var(--manpower-color);"></i>
                            <strong>Manpower:</strong> People</li>
                        <li><i class="fas fa-cogs" style="color: var(--methods-color);"></i> <strong>Methods:</strong>
                            Processes</li>
                        <li><i class="fas fa-robot" style="color: var(--machines-color);"></i>
                            <strong>Machines:</strong> Equipment</li>
                        <li><i class="fas fa-boxes" style="color: var(--materials-color);"></i>
                            <strong>Materials:</strong> Components</li>
                        <li><i class="fas fa-tree" style="color: var(--environment-color);"></i>
                            <strong>Environment:</strong> External Factors</li>
                        <li><i class="fas fa-chart-line" style="color: var(--measurement-color);"></i>
                            <strong>Measurement:</strong> Data</li>
                    </ul>
                </div>
            </div>
        </div>
    </main>
    <footer>
        <div class="disclaimer-note">
            <p><strong>Disclaimer:</strong> The tools and information provided on Sigma Exacta are for informational and
                educational purposes only. This tool is an independent implementation inspired by the Cause and Effect
                Diagram developed by Dr. Kaoru Ishikawa and is not affiliated with any official quality organizations.
                While we strive for accuracy, we make no warranty or guarantee regarding the results obtained from this
                tool. All decisions based on the output are the sole responsibility of the user. Sigma Exacta and its
                creators are not liable for any damages or losses resulting from its use.</p>
        </div>
    </footer>
    <script>
        /**
         * Inicializa la funcionalidad del menú (toggle, dropdowns)
         * Esta función se llama DESPUÉS de que el header se carga dinámicamente.
         */
        function initializeHeaderMenu() {
            const navToggle = document.getElementById('nav-toggle');
            const navMenu = document.getElementById('nav-menu');
            const toolsDropdownToggle = document.getElementById('tools-dropdown-toggle');
            const toolsDropdownMenu = document.getElementById('tools-dropdown-menu');
            const toolsDropdownContainer = document.getElementById('tools-dropdown-container');

            if (navToggle) {
                navToggle.addEventListener('click', () => {
                    navMenu.classList.toggle('show-menu');
                    const icon = navToggle.querySelector('i');
                    icon.classList.toggle('fa-bars');
                    icon.classList.toggle('fa-times');

                    if (!navMenu.classList.contains('show-menu')) {
                        if (toolsDropdownMenu) toolsDropdownMenu.classList.remove('show-submenu');
                        if (toolsDropdownContainer) toolsDropdownContainer.classList.remove('active');
                    }
                });
            }

            if (toolsDropdownToggle) {
                toolsDropdownToggle.addEventListener('click', (event) => {
                    if (window.innerWidth <= 992) {
                        event.preventDefault();
                        if (toolsDropdownMenu) toolsDropdownMenu.classList.toggle('show-submenu');
                        if (toolsDropdownContainer) toolsDropdownContainer.classList.toggle('active');
                    }
                });
            }

            // Clicks fuera del menu (para móvil)
            document.addEventListener('click', (event) => {
                if (!navMenu || !navToggle) return;
                // Comprobar si navMenu o navToggle existen antes de usar .contains
                const isClickInsideNav = (navMenu && navMenu.contains(event.target)) || (navToggle && navToggle.contains(event.target));
                if (!isClickInsideNav && navMenu && navMenu.classList.contains('show-menu')) {
                    navMenu.classList.remove('show-menu');
                    const icon = navToggle.querySelector('i');
                    if (icon) {
                        icon.classList.remove('fa-times');
                        icon.classList.add('fa-bars');
                    }
                    if (toolsDropdownMenu) toolsDropdownMenu.classList.remove('show-submenu');
                    if (toolsDropdownContainer) toolsDropdownContainer.classList.remove('active');
                }
            });
        }

        /**
         * Carga dinámicamente el header desde header.html
         */
        function loadHeader() {
            fetch('header.html')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.text();
                })
                .then(data => {
                    document.getElementById('header-container').innerHTML = data;
                    // Una vez cargado el HTML, inicializa los scripts del menú
                    initializeHeaderMenu();
                })
                .catch(error => {
                    console.error('Error loading header:', error);
                    document.getElementById('header-container').innerHTML = '<p style="color:red; text-align:center;">Error loading header.</p>';
                });
        }

        document.addEventListener('DOMContentLoaded', function () {
            // Cargar el header dinámicamente
            loadHeader();

            // El resto del script de la página (no relacionado con el header) se ejecuta como antes
            createCategoryUI();
            resetData(true);
        });

        const categoryData = [
            { key: 'manpower', name: 'Manpower', icon: 'fa-users', color: 'var(--manpower-color)' },
            { key: 'methods', name: 'Methods', icon: 'fa-cogs', color: 'var(--methods-color)' },
            { key: 'machines', name: 'Machines', icon: 'fa-robot', color: 'var(--machines-color)' },
            { key: 'materials', name: 'Materials', icon: 'fa-boxes', color: 'var(--materials-color)' },
            { key: 'environment', name: 'Environment', icon: 'fa-tree', color: 'var(--environment-color)' },
            { key: 'measurement', name: 'Measurement', icon: 'fa-chart-line', color: 'var(--measurement-color)' },
        ];

        let currentData = { problem: '', categories: {} };
        const placeholderProblemText = 'Enter problem here';

        // ===================================================================================
        // --- IMPROVED ISHIKAWA DIAGRAM LOGIC ---
        // ===================================================================================

        const diagramNodes = new Map();

        function createSVGElement(tag, attributes) {
            const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
            for (const key in attributes) {
                el.setAttribute(key, attributes[key]);
            }
            return el;
        }

        function wrapText(textElement, text, maxWidth) {
            textElement.innerHTML = '';
            const words = text.split(/\s+/);
            let line = '';
            const x = textElement.getAttribute('x');
            const y = textElement.getAttribute('y');

            let tspan = createSVGElement('tspan', { x: x, dy: '0em' });
            textElement.appendChild(tspan);

            words.forEach(word => {
                const testLine = line ? `${line} ${word}` : word;
                tspan.textContent = testLine;
                if (tspan.getComputedTextLength() > maxWidth) {
                    tspan.textContent = line;
                    line = word;
                    tspan = createSVGElement('tspan', { x: x, dy: '1.2em' });
                    tspan.textContent = line;
                    textElement.appendChild(tspan);
                } else {
                    line = testLine;
                }
            });

            const textHeight = textElement.getBBox().height;
            const initialY = parseFloat(y);
            const verticalCenterOffset = initialY - (textElement.getBBox().y + textHeight / 2);
            textElement.setAttribute('transform', `translate(0, ${verticalCenterOffset})`);
        }

        // ==========================================================
        // --- INICIO: NUEVO ALGORITMO DE AJUSTE DE COLISIONES ---
        // ==========================================================
        /**
         * Ajusta las colisiones de un grupo de elementos (ej. todas las causas de una rama)
         * Ordenándolos por su posición 'y' y empujándolos si se solapan.
         */
        function adjustBranchCollisions(elements, isTopBranch) {
            if (elements.length < 2) return;

            const MARGIN = 5; // 5px de margen entre cajas de texto

            // 1. Obtener elementos y sus BBoxes, luego ordenar por 'y'
            const sortedElements = elements
                .map(el => ({ el, bbox: el.getBBox() }))
                .sort((a, b) => {
                    // Si la rama está abajo, ordenamos de abajo hacia arriba
                    return isTopBranch ? a.bbox.y - b.bbox.y : b.bbox.y - a.bbox.y;
                });

            // 2. Iterar y empujar
            for (let i = 0; i < sortedElements.length - 1; i++) {
                const el1 = sortedElements[i].el;
                const rect1 = el1.getBBox(); // Obtener BBox fresca

                const el2 = sortedElements[i + 1].el;
                let rect2 = el2.getBBox(); // Obtener BBox fresca

                let overlap;
                if (isTopBranch) {
                    // Rama de arriba: Comprobar si la parte inferior de 1 solapa con la superior de 2
                    overlap = (rect1.y + rect1.height + MARGIN) - rect2.y;
                } else {
                    // Rama de abajo: Comprobar si la parte superior de 1 solapa con la inferior de 2
                    overlap = (rect2.y + rect2.height + MARGIN) - rect1.y;
                }

                if (overlap > 0) {
                    // Hay solapamiento. Mover el elemento 2.
                    const node2 = diagramNodes.get(el2);
                    if (!node2) continue;

                    // El empuje es en la dirección opuesta a la rama
                    const dy = isTopBranch ? overlap : -overlap;
                    const newY = parseFloat(el2.getAttribute('y')) + dy;

                    el2.setAttribute('y', newY);
                    node2.initialPos.y = newY; // Actualizar para drag-and-drop

                    // Mover la línea también
                    if (node2.line) {
                        node2.line.setAttribute('y2', newY);
                    }

                    // Actualizar la BBox del elemento movido para la siguiente iteración
                    sortedElements[i + 1].bbox = el2.getBBox();
                }
            }
        }
        // ==========================================================
        // --- FIN: NUEVO ALGORITMO DE AJUSTE DE COLISIONES ---
        // ==========================================================


        function drawIshikawa(problem, categories) {
            const svg = document.getElementById('ishikawaSvgContainer');
            svg.innerHTML = '';
            diagramNodes.clear();

            const { width, height } = svg.getBoundingClientRect();

            const isMobile = window.innerWidth <= 768;
            const margin = isMobile
                ? { top: 30, right: 120, bottom: 60, left: 30 }
                : { top: 40, right: 200, bottom: 80, left: 50 };

            const diagramWidth = width - margin.left - margin.right;
            const diagramHeight = height - margin.top - margin.bottom;

            const spineY = margin.top + diagramHeight / 2;
            const spineStartX = margin.left;
            const spineEndX = margin.left + diagramWidth;

            const diagramGroup = createSVGElement('g', { id: 'diagram-group' });
            svg.appendChild(diagramGroup);

            // Logo
            diagramGroup.appendChild(createSVGElement('image', {
                href: 'sigma-exacta-icon.jpg',
                x: 10, y: 10, width: 40, height: 40, opacity: 0.7
            }));

            // Nota de instrucción
            const noteText = createSVGElement('text', {
                x: 55, y: 30, fill: '#888',
                'font-size': isMobile ? '10px' : '12px',
                'font-style': 'italic',
                'dominant-baseline': 'middle'
            });
            noteText.textContent = 'Drag & drop text to adjust the diagram';
            diagramGroup.appendChild(noteText);

            // Dibujar la espina principal
            diagramGroup.appendChild(createSVGElement('line', {
                x1: spineStartX, y1: spineY, x2: spineEndX, y2: spineY,
                stroke: '#333', 'stroke-width': 3
            }));

            // Flecha al final de la espina
            diagramGroup.appendChild(createSVGElement('polygon', {
                points: `${spineEndX},${spineY} ${spineEndX - 15},${spineY - 7} ${spineEndX - 15},${spineY + 7}`,
                fill: '#333'
            }));

            // Caja del problema
            const problemBoxWidth = isMobile ? 140 : 180;
            const problemBoxHeight = isMobile ? 50 : 60;

            diagramGroup.appendChild(createSVGElement('rect', {
                x: spineEndX + 5, y: spineY - problemBoxHeight / 2,
                width: problemBoxWidth, height: problemBoxHeight,
                class: 'problem-box',
                rx: 8,
                stroke: '#333',
                'stroke-width': 1
            }));

            const problemText = createSVGElement('text', {
                x: spineEndX + 5 + problemBoxWidth / 2,
                y: spineY,
                class: 'problem-text',
                'font-size': isMobile ? '12px' : '14px'
            });
            diagramGroup.appendChild(problemText);
            wrapText(problemText, problem, problemBoxWidth - 10);

            const topCategories = categoryData.slice(0, 3);
            const bottomCategories = categoryData.slice(3, 6);

            const drawCategoryBranch = (cat, index, isTop) => {
                const boneAngle = isTop ? -45 : 45;
                const boneAngleRad = boneAngle * Math.PI / 180;

                const boneLength = isMobile
                    ? Math.min(diagramWidth / 4, diagramHeight / 2.5)
                    : Math.min(diagramWidth / 3.5, diagramHeight / 2.2);

                const boneStartX = spineStartX + (diagramWidth / (topCategories.length + 1)) * (index + 1);
                const boneEndX = boneStartX + boneLength * Math.cos(boneAngleRad);
                const boneEndY = spineY + boneLength * Math.sin(boneAngleRad);

                const bone = createSVGElement('line', {
                    x1: boneStartX, y1: spineY, x2: boneEndX, y2: boneEndY,
                    stroke: cat.color, class: 'category-bone'
                });
                diagramGroup.appendChild(bone);

                const textYOffset = isTop ? -20 : 20;
                const catText = createSVGElement('text', {
                    x: boneEndX, y: boneEndY + textYOffset,
                    fill: cat.color,
                    class: 'main-category-text draggable',
                    'font-size': isMobile ? '12px' : '14px'
                });
                catText.textContent = cat.name;
                diagramGroup.appendChild(catText);

                diagramNodes.set(catText, {
                    line: bone,
                    children: [],
                    initialPos: { x: boneEndX, y: boneEndY + textYOffset },
                    parent: null,
                    fraction: 0
                });
                makeDraggable(catText);

                const causes = categories[cat.key] || [];

                // --- INICIO LÓGICA DE AJUSTE ---
                const causeElementsInBranch = [];
                // --- FIN LÓGICA DE AJUSTE ---

                causes.forEach((cause, causeIdx) => {
                    const fraction = (causeIdx + 1) / (causes.length + 1);
                    const causeStartX = boneStartX + (boneEndX - boneStartX) * fraction;
                    const causeStartY = spineY + (boneEndY - spineY) * fraction;

                    const causeBranchLength = isMobile ? 50 : 70;
                    const causeBranchEndX = causeStartX + (isTop ? causeBranchLength : -causeBranchLength);
                    const causeBranchEndY = causeStartY;

                    const causeLine = createSVGElement('line', {
                        x1: causeStartX, y1: causeStartY, x2: causeBranchEndX, y2: causeBranchEndY,
                        stroke: cat.color, class: 'cause-line'
                    });
                    diagramGroup.appendChild(causeLine);

                    const causeText = createSVGElement('text', {
                        x: causeBranchEndX + (isTop ? 8 : -8),
                        y: causeBranchEndY,
                        fill: '#333',
                        'text-anchor': isTop ? 'start' : 'end',
                        'dominant-baseline': 'middle',
                        class: 'cause-text draggable',
                        'font-size': isMobile ? '10px' : '12px'
                    });
                    causeText.textContent = cause.text;
                    diagramGroup.appendChild(causeText);

                    diagramNodes.set(causeText, {
                        line: causeLine,
                        children: [],
                        initialPos: { x: causeBranchEndX + (isTop ? 8 : -8), y: causeBranchEndY },
                        parent: catText,
                        fraction: fraction
                    });
                    diagramNodes.get(catText).children.push(causeText);
                    makeDraggable(causeText);

                    // --- INICIO LÓGICA DE AJUSTE ---
                    causeElementsInBranch.push(causeText);
                    const subCauseElementsInBranch = [];
                    // --- FIN LÓGICA DE AJUSTE ---

                    const subCauses = cause.subCauses || [];
                    subCauses.forEach((subCause, subCauseIdx) => {
                        const subFraction = (subCauseIdx + 1) / (subCauses.length + 1); // Distribuir uniformemente
                        const subCauseStartX = causeStartX + (causeBranchEndX - causeStartX) * subFraction;
                        const subCauseStartY = causeStartY; // Start on the horizontal cause line

                        // 2. Get alternating angle
                        const isAlternating = subCauseIdx % 2 !== 0; // true for 1, 3, 5
                        const currentAngle = isAlternating ? (-boneAngle) : (boneAngle); // e.g., idx 0 = -45, idx 1 = +45
                        const subCauseBranchAngleRad = currentAngle * Math.PI / 180;

                        // 3. Get length
                        const subCauseBranchLength = isMobile ? 40 : 60;

                        // 4. Calculate End Point (directional)
                        const directionalLength = isTop ? subCauseBranchLength : -subCauseBranchLength;
                        const subCauseBranchEndX = subCauseStartX + directionalLength * Math.cos(subCauseBranchAngleRad);
                        const subCauseBranchEndY = subCauseStartY + directionalLength * Math.sin(subCauseBranchAngleRad);

                        // 5. Draw line
                        const subCauseLine = createSVGElement('line', {
                            x1: subCauseStartX, y1: subCauseStartY, x2: subCauseBranchEndX, y2: subCauseBranchEndY,
                            stroke: cat.color, class: 'subcause-line'
                        });
                        diagramGroup.appendChild(subCauseLine);

                        // 6. Draw Text (with correct anchor)
                        const textAnchor = isTop ? 'start' : 'end';
                        const textXOffset = isTop ? 8 : -8;

                        const subCauseText = createSVGElement('text', {
                            x: subCauseBranchEndX + textXOffset,
                            y: subCauseBranchEndY,
                            fill: '#555',
                            'text-anchor': textAnchor,
                            'dominant-baseline': 'middle',
                            class: 'subcause-text draggable',
                            'font-size': isMobile ? '9px' : '11px'
                        });
                        subCauseText.textContent = subCause.text;
                        diagramGroup.appendChild(subCauseText);

                        // 7. Update node map
                        diagramNodes.set(subCauseText, {
                            line: subCauseLine,
                            children: [],
                            initialPos: { x: parseFloat(subCauseText.getAttribute('x')), y: parseFloat(subCauseText.getAttribute('y')) },
                            parent: causeText,
                            fraction: subFraction
                        });
                        diagramNodes.get(causeText).children.push(subCauseText);
                        makeDraggable(subCauseText);

                        // --- INICIO LÓGICA DE AJUSTE ---
                        subCauseElementsInBranch.push(subCauseText);
                        // --- FIN LÓGICA DE AJUSTE ---
                    });

                    // --- INICIO LÓGICA DE AJUSTE ---
                    // Ajustar las sub-causas de ESTA causa
                    adjustBranchCollisions(subCauseElementsInBranch, isTop);
                    // --- FIN LÓGICA DE AJUSTE ---
                });

                // --- INICIO LÓGICA DE AJUSTE ---
                // Ajustar las causas principales de ESTA categoría
                adjustBranchCollisions(causeElementsInBranch, isTop);
                // --- FIN LÓGICA DE AJUSTE ---
            };

            topCategories.forEach((cat, i) => drawCategoryBranch(cat, i, true));
            bottomCategories.forEach((cat, i) => drawCategoryBranch(cat, i, false));
        }

        function makeDraggable(element) {
            let isDragging = false;
            let initialMousePos = { x: 0, y: 0 };

            element.addEventListener('mousedown', startDrag);

            function startDrag(e) {
                e.preventDefault();
                isDragging = true;
                const CTM = element.ownerSVGElement.getScreenCTM();
                initialMousePos = { x: (e.clientX - CTM.e) / CTM.a, y: (e.clientY - CTM.f) / CTM.d };

                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', endDrag);
            }

            function drag(e) {
                if (!isDragging) return;
                const CTM = element.ownerSVGElement.getScreenCTM();
                const currentMousePos = { x: (e.clientX - CTM.e) / CTM.a, y: (e.clientY - CTM.f) / CTM.d };
                const dx = currentMousePos.x - initialMousePos.x;
                const dy = currentMousePos.y - initialMousePos.y;
                updateTreePosition(element, dx, dy);
            }

            function endDrag() {
                if (!isDragging) return;
                isDragging = false;
                for (const [el, node] of diagramNodes.entries()) {
                    node.initialPos.x = parseFloat(el.getAttribute('x'));
                    node.initialPos.y = parseFloat(el.getAttribute('y'));
                }
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('mouseup', endDrag);
            }
        }

        function updateTreePosition(element, dx, dy) {
            const node = diagramNodes.get(element);
            if (!node) return;

            const newX = node.initialPos.x + dx;
            const newY = node.initialPos.y + dy;
            element.setAttribute('x', newX);
            element.setAttribute('y', newY);

            const { line } = node;
            if (line) {
                const textAnchor = element.getAttribute('text-anchor');
                let xOffset = 0;

                if (textAnchor === 'start') xOffset = -5;
                if (textAnchor === 'end') xOffset = 5;

                line.setAttribute('x2', newX + xOffset);
                line.setAttribute('y2', newY);
            }

            node.children.forEach(childElement => {
                const childNode = diagramNodes.get(childElement);
                if (line && childNode) {
                    const lineX1 = parseFloat(line.getAttribute('x1'));
                    const lineY1 = parseFloat(line.getAttribute('y1'));
                    const lineX2 = parseFloat(line.getAttribute('x2'));
                    const lineY2 = parseFloat(line.getAttribute('y2'));

                    const newChildStartX = lineX1 + (lineX2 - lineX1) * childNode.fraction;
                    const newChildStartY = lineY1 + (lineY2 - lineY1) * childNode.fraction;

                    childNode.line.setAttribute('x1', newChildStartX);
                    childNode.line.setAttribute('y1', newChildStartY);
                }
                updateTreePosition(childElement, dx, dy);
            });
        }

        // ===================================================================================
        // --- EXISTING UI AND DATA HANDLING LOGIC (UNCHANGED) ---
        // ===================================================================================

        function createCategoryUI() {
            const container = document.getElementById('categories-container');
            container.innerHTML = '';
            categoryData.forEach(cat => {
                const section = document.createElement('div');
                section.className = 'category-section';
                section.innerHTML = `
              <label class="category-label" style="color: ${cat.color};"><i class="fas ${cat.icon}"></i> ${cat.name}</label>
              <div id="${cat.key}-causes" class="category-causes-container"></div>
              <button type="button" class="add-cause-btn success" data-category="${cat.key}">➕ Add Cause</button>
          `;
                container.appendChild(section);
            });
        }

        function addCauseBlock(categoryKey, causeText = '', subCauses = []) {
            const container = document.getElementById(`${categoryKey}-causes`);
            const causeBlock = document.createElement('div');
            causeBlock.className = 'cause-block';

            const subCausesHTML = subCauses.map((subCause, index) => {
                const subSubCausesHTML = (subCause.subSubCauses || []).map(subSubCause => `
          <div class="sub-sub-cause-item">
              <input type="text" class="sub-sub-cause-input" placeholder="Sub-sub-cause..." value="${subSubCause}">
              <button type="button" class="action-button danger remove-sub-sub-cause-btn" title="Remove sub-sub-cause">-</button>
          </div>
        `).join('');

                return `
          <div class="sub-cause-item">
              <input type="text" class="sub-cause-input" placeholder="Sub-cause..." value="${subCause.text}">
              <button type="button" class="action-button danger remove-sub-cause-btn" title="Remove sub-cause">-</button>
              <button type="button" class="add-sub-sub-cause-btn success action-button" title="Add sub-sub-cause">+</button>
              <div class="sub-sub-causes-container">${subSubCausesHTML}</div>
          </div>
        `;
            }).join('');

            causeBlock.innerHTML = `
          <div class="cause-input-wrapper">
              <input type="text" class="cause-input" placeholder="Main cause..." value="${causeText}">
              <button type="button" class="action-button danger remove-cause-btn" title="Remove cause and sub-causes">X</button>
          </div>
          <div class="sub-causes-container">${subCausesHTML}</div>
          <button type="button" class="add-sub-cause-btn success action-button" title="Add sub-cause">+</button>
      `;
            container.appendChild(causeBlock);

            // ACTUALIZAR DIAGRAMA DESPUÉS DE AGREGAR CAUSA
            setTimeout(() => {
                const problem = document.getElementById("problem").value.trim();
                if (problem) {
                    const categories = collectDataFromDOM();
                    drawIshikawa(problem, categories);
                }
            }, 10);
        }

        function addSubCauseInput(button) {
            const container = button.previousElementSibling;
            const subCauseItem = document.createElement('div');
            subCauseItem.className = 'sub-cause-item';
            subCauseItem.innerHTML = `
          <input type="text" class="sub-cause-input" placeholder="Sub-cause...">
          <button type="button" class="action-button danger remove-sub-cause-btn" title="Remove sub-cause">-</button>
          <button type="button" class="add-sub-sub-cause-btn success action-button" title="Add sub-sub-cause">+</button>
          <div class="sub-sub-causes-container"></div>
      `;
            container.appendChild(subCauseItem);
            subCauseItem.querySelector('input').focus();

            // ACTUALIZAR DIAGRAMA DESPUÉS DE AGREGAR SUB-CAUSA
            setTimeout(() => {
                const problem = document.getElementById("problem").value.trim();
                if (problem) {
                    const categories = collectDataFromDOM();
                    drawIshikawa(problem, categories);
                }
            }, 10);
        }

        function addSubSubCauseInput(button) {
            const container = button.nextElementSibling;
            const subSubCauseItem = document.createElement('div');
            subSubCauseItem.className = 'sub-sub-cause-item';
            subSubCauseItem.innerHTML = `
          <input type="text" class="sub-sub-cause-input" placeholder="Sub-sub-cause...">
          <button type="button" class="action-button danger remove-sub-sub-cause-btn" title="Remove sub-sub-cause">-</button>
      `;
            container.appendChild(subSubCauseItem);
            subSubCauseItem.querySelector('input').focus();

            // ACTUALIZAR DIAGRAMA DESPUÉS DE AGREGAR SUB-SUB-CAUSA
            setTimeout(() => {
                const problem = document.getElementById("problem").value.trim();
                if (problem) {
                    const categories = collectDataFromDOM();
                    drawIshikawa(problem, categories);
                }
            }, 10);
        }

        // FUNCIÓN PARA ACTUALIZAR DIAGRAMA CUANDO SE ELIMINAN CAUSAS
        function updateDiagram() {
            const problem = document.getElementById("problem").value.trim();
            if (problem) {
                const categories = collectDataFromDOM();
                drawIshikawa(problem, categories);
            }
        }

        document.getElementById('categories-container').addEventListener('click', function (e) {
            const target = e.target.closest('button');
            if (!target) return;
            if (target.classList.contains('add-cause-btn')) {
                addCauseBlock(target.dataset.category);
            }
            if (target.classList.contains('remove-cause-btn')) {
                target.closest('.cause-block').remove();
                updateDiagram(); // ACTUALIZAR DIAGRAMA AL ELIMINAR CAUSA
            }
            if (target.classList.contains('add-sub-cause-btn')) {
                addSubCauseInput(target);
            }
            if (target.classList.contains('remove-sub-cause-btn')) {
                target.closest('.sub-cause-item').remove();
                updateDiagram(); // ACTUALIZAR DIAGRAMA AL ELIMINAR SUB-CAUSA
            }
            if (target.classList.contains('add-sub-sub-cause-btn')) {
                addSubSubCauseInput(target);
            }
            if (target.classList.contains('remove-sub-sub-cause-btn')) {
                target.closest('.sub-sub-cause-item').remove();
                updateDiagram(); // ACTUALIZAR DIAGRAMA AL ELIMINAR SUB-SUB-CAUSA
            }
        });

        // ACTUALIZAR DIAGRAMA CUANDO SE CAMBIA EL TEXTO DE LAS CAUSAS
        document.getElementById('categories-container').addEventListener('input', function (e) {
            if (e.target.classList.contains('cause-input') ||
                e.target.classList.contains('sub-cause-input') ||
                e.target.classList.contains('sub-sub-cause-input')) {
                const problem = document.getElementById("problem").value.trim();
                if (problem) {
                    const categories = collectDataFromDOM();
                    drawIshikawa(problem, categories);
                }
            }
        });

        function collectDataFromDOM() {
            const categories = {};
            categoryData.forEach(cat => {
                categories[cat.key] = [];
                const causeBlocks = document.querySelectorAll(`#${cat.key}-causes .cause-block`);
                causeBlocks.forEach(block => {
                    const causeText = block.querySelector('.cause-input').value.trim();
                    if (causeText) {
                        const subCauses = [];
                        const subCauseItems = block.querySelectorAll('.sub-cause-item');
                        subCauseItems.forEach(subCauseItem => {
                            const subCauseText = subCauseItem.querySelector('.sub-cause-input').value.trim();
                            if (subCauseText) {
                                const subSubCauses = Array.from(subCauseItem.querySelectorAll('.sub-sub-cause-input'))
                                    .map(input => input.value.trim())
                                    .filter(Boolean);
                                subCauses.push({ text: subCauseText, subSubCauses: subSubCauses });
                            }
                        });
                        categories[cat.key].push({ text: causeText, subCauses: subCauses });
                    }
                });
            });
            return categories;
        }

        function generateIshikawa() {
            const problem = document.getElementById("problem").value.trim();
            if (!problem) {
                alert("⚠️ Please enter a problem statement.");
                return;
            }
            const categories = collectDataFromDOM();
            currentData = { problem, categories };
            setTimeout(() => drawIshikawa(problem, categories), 10);
        }

        function loadExample() {
            resetData(false);
            document.getElementById("problem").value = "Engine Overheating in Automotive Assembly Line";
            const exampleData = {
                manpower: [
                    {
                        text: "Insufficient training",
                        subCauses: [
                            { text: "New hires not trained" },
                            { text: "No refresher courses" }
                        ]
                    },
                    {
                        text: "High turnover rate",
                        subCauses: [{ text: "Loss of experienced staff" }]
                    }
                ],
                methods: [
                    { text: "Incorrect assembly sequence", subCauses: [{ text: "Wrong torque sequence" }] },
                    { text: "Improper coolant filling", subCauses: [{ text: "Air pockets in system" }, { text: "Wrong coolant mixture" }] }
                ],
                machines: [
                    { text: "Faulty torque wrenches", subCauses: [{ text: "No calibration records" }] },
                    { text: "Coolant station malfunction", subCauses: [{ text: "Inconsistent pressure" }] }
                ],
                materials: [
                    { text: "Low quality gaskets", subCauses: [{ text: "Supplier quality issues" }] },
                    { text: "Contaminated coolant", subCauses: [{ text: "Storage contamination" }] }
                ],
                environment: [
                    { text: "High humidity in area", subCauses: [{ text: "Affects sensor calibration" }] },
                    { text: "Temperature fluctuations" }
                ],
                measurement: [
                    { text: "Inaccurate pressure testing", subCauses: [{ text: "Faulty pressure gauges" }] },
                    { text: "Incorrect torque verification" }
                ]
            };
            for (const categoryKey in exampleData) {
                exampleData[categoryKey].forEach(cause => {
                    addCauseBlock(categoryKey, cause.text, cause.subCauses);
                });
            }
            generateIshikawa();
        }

        function resetData(redraw = true) {
            document.getElementById("ishikawaForm").reset();
            createCategoryUI();
            currentData = { problem: placeholderProblemText, categories: {} };
            if (redraw) {
                setTimeout(() => drawIshikawa(currentData.problem, currentData.categories), 10);
            }
        }

        function exportToExcel() {
            if (!currentData.problem || currentData.problem === placeholderProblemText) {
                alert('⚠️ Please generate a diagram with a problem statement before exporting.');
                return;
            }
            const excelData = [['Problem Statement:', currentData.problem], [], ['Category', 'Cause', 'Sub-Cause', 'Sub-Sub-Cause']];
            categoryData.forEach(catInfo => {
                const causes = currentData.categories[catInfo.key] || [];
                if (causes.length > 0) {
                    let isFirstCauseOfCategory = true;
                    causes.forEach(cause => {
                        const categoryCell = isFirstCauseOfCategory ? catInfo.name : '';
                        if (cause.subCauses && cause.subCauses.length > 0) {
                            cause.subCauses.forEach((subCause, i) => {
                                if (subCause.subSubCauses && subCause.subSubCauses.length > 0) {
                                    subCause.subSubCauses.forEach((subSubCause, j) => {
                                        if (j === 0) {
                                            if (i === 0) {
                                                excelData.push([categoryCell, cause.text, subCause.text, subSubCause]);
                                            } else {
                                                excelData.push(['', '', subCause.text, subSubCause]);
                                            }
                                        } else {
                                            excelData.push(['', '', '', subSubCause]);
                                        }
                                    });
                                } else {
                                    if (i === 0) {
                                        excelData.push([categoryCell, cause.text, subCause.text, '']);
                                    } else {
                                        excelData.push(['', '', subCause.text, '']);
                                    }
                                }
                            });
                        } else {
                            excelData.push([categoryCell, cause.text, '', '']);
                        }
                        isFirstCauseOfCategory = false;
                    });
                } else {
                    excelData.push([catInfo.name, '', '', '']);
                }
                excelData.push([]);
            });
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.aoa_to_sheet(excelData);
            ws['!cols'] = [{ wch: 20 }, { wch: 35 }, { wch: 35 }, { wch: 35 }];
            XLSX.utils.book_append_sheet(wb, ws, 'Ishikawa Data');
            XLSX.writeFile(wb, 'Ishikawa_Diagram_Data_Sigma_Exacta.xlsx');
        }

        // SOLUCIÓN DEFINITIVA: Usando html2canvas para capturar exactamente lo que se ve
        function exportToJpg() {
            if (!currentData.problem || currentData.problem === placeholderProblemText) {
                alert('⚠️ Please generate a diagram before exporting.');
                return;
            }

            const diagramContainer = document.getElementById('ishikawaDiagramContainer');

            // Mostrar mensaje de procesamiento
            const originalText = document.getElementById('exportJpgBtn').innerHTML;
            document.getElementById('exportJpgBtn').innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
            document.getElementById('exportJpgBtn').disabled = true;

            // Configuración para html2canvas
            const options = {
                scale: 2, // Doble resolución para mejor calidad
                useCORS: true, // Permitir imágenes cross-origin
                allowTaint: true, // Permitir imágenes no CORS
                backgroundColor: '#ffffff', // Fondo blanco
                logging: false, // Desactivar logs
                onclone: function (clonedDoc) {
                    // Asegurar que el SVG se vea bien en el clon
                    const clonedSvg = clonedDoc.getElementById('ishikawaSvgContainer');
                    if (clonedSvg) {
                        clonedSvg.style.width = '100%';
                        clonedSvg.style.height = '100%';
                    }
                }
            };

            // Capturar el diagrama completo con html2canvas
            html2canvas(diagramContainer, options).then(canvas => {
                // Convertir a JPG
                const jpgData = canvas.toDataURL('image/jpeg', 0.95);

                // Crear enlace de descarga
                const link = document.createElement('a');
                link.download = 'Ishikawa_Diagram_Sigma_Exacta.jpg';
                link.href = jpgData;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                // Restaurar botón
                document.getElementById('exportJpgBtn').innerHTML = originalText;
                document.getElementById('exportJpgBtn').disabled = false;
            }).catch(error => {
                console.error('Error generating JPG:', error);
                alert('Error generating JPG image. Please try again.');

                // Restaurar botón
                document.getElementById('exportJpgBtn').innerHTML = originalText;
                document.getElementById('exportJpgBtn').disabled = false;
            });
        }

        document.getElementById("ishikawaForm").addEventListener("submit", (e) => { e.preventDefault(); generateIshikawa(); });
        document.getElementById("exampleBtn").addEventListener("click", loadExample);
        document.getElementById("resetBtn").addEventListener("click", () => resetData(true));
        document.getElementById("exportBtn").addEventListener("click", exportToExcel);
        document.getElementById("exportJpgBtn").addEventListener("click", exportToJpg);

        // ACTUALIZAR DIAGRAMA CUANDO CAMBIA EL PROBLEMA
        document.getElementById("problem").addEventListener("input", function () {
            const problem = this.value.trim();
            if (problem) {
                const categories = collectDataFromDOM();
                drawIshikawa(problem, categories);
            }
        });

        window.addEventListener('resize', () => {
            if (currentData.problem && currentData.problem !== placeholderProblemText) {
                drawIshikawa(currentData.problem, currentData.categories);
            }
        });
    </script>

</body>

</html>