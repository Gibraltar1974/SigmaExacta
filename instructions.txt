This URL would:
1. Set experiment name to "My Experiment"
2. Create two factors: Temperature (levels: Low, High) and Pressure (levels: 10psi, 20psi)
3. Populate results: 10.2, 9.8, 12.1, 11.5
4. Automatically run the full Taguchi analysis

G. UI FEEDBACK:
- Visual indicator shows when parameters are loaded
- Console logging for debugging
- Notification system for errors or warnings

H. ERROR HANDLING:
- Graceful handling of missing fields
- Validation of parameter values
- Fallback mechanisms for partial data

I. EXTENSION POINTS:
- Additional tool-specific handlers can be added
- Custom field mappings for new tools
- Enhanced parameter validation
- Support for array/object parameters in JSON format

================================================================================
TOOL 0: 8D PROBLEM SOLVING TOOL & REPORT GENERATOR
================================================================================

APPLICATION OVERVIEW:
This is a free online 8D (Eight Disciplines) Problem Solving tool that guides users through the structured 8D methodology to identify root causes, implement corrective actions, and generate professional reports. The tool is designed for manufacturing, engineering, and quality teams.

KEY COMPONENTS:

1. DATA INPUT SYSTEM:
- Three main tabs: Start & Info, 8D Form, Report
- 8D Form tab with 8 sub-tabs for each discipline (D0 to D7)
- Each sub-tab contains form fields for the corresponding discipline
- Auto-expanding textareas for better user experience

2. CALCULATION ENGINE:
- Data collection from all 8 disciplines
- Generation of a summary report
- Export to Excel with detailed data

3. VISUALIZATION SYSTEM:
- Summary report display in the Report tab
- Printable report section

4. UI STRUCTURE:
- Wizard-style tabs and sub-tabs
- Main action buttons (Load Example, Reset All) above tabs
- Responsive design for all device sizes

5. URL PARAMETER SUPPORT:
- Parameters for each form field (see field mapping below)
- tab: Main tab to display (tab-start, tab-form, tab-report)
- sub_tab: Sub-tab within 8D Form (sub-tab-d0, sub-tab-d1, ... sub-tab-d7)
- auto_calculate: Trigger automatic report generation (1 or true)

HOW TO INTERACT WITH THE JAVASCRIPT:

A. INITIALIZATION:
- The application loads with empty form fields
- Event listeners are set up for tab switching, buttons, etc.
- SheetJS library is loaded for Excel export

B. CORE FUNCTIONS:

1. switchTab(tabId)
   - Switches between main tabs
   - Updates active tab styling

2. switchSubTab(subTabId)
   - Switches between sub-tabs in the 8D Form
   - Updates active sub-tab styling

3. loadExample()
   - Populates all form fields with example data
   - Switches to the 8D Form tab and first sub-tab

4. resetTool()
   - Resets all form fields and hides the results

5. generateReportSummary()
   - Validates the form and generates a summary report
   - Displays the report in the Report tab

6. exportToExcel()
   - Exports the complete 8D data to an Excel file

C. DATA FLOW:
1. User enters data in the 8D Form sub-tabs
2. Generate Report Summary collects the data and displays a summary
3. Export to Excel creates a detailed Excel file

D. UI UPDATES:
- Tabs and sub-tabs switch with smooth animations
- Textareas auto-expand based on content
- Report section becomes visible after generation

E. URL PARAMETER INTEGRATION:
- The Query Handler will inject parameters into the corresponding form fields.
- Field mapping: Parameter names are derived from the field IDs by converting to lowercase and replacing hyphens with underscores. For example, 'teamLeader' becomes 'team_leader'.
- Special parameters:
  - 'tab' sets the active main tab.
  - 'sub_tab' sets the active sub-tab within the 8D Form.
  - 'auto_calculate' triggers the report generation automatically.

Example URL:
https://sigmaexacta.com/8d.html?team_leader=John&problem_statement=Defect&tab=tab-form&sub_tab=sub-tab-d1&auto_calculate=1

This URL would:
1. Set team leader to "John"
2. Set problem statement to "Defect"
3. Open the 8D Form tab
4. Open the D1 sub-tab
5. Automatically generate the report

F. UI FEEDBACK:
- Notification system for actions (load example, reset, export)
- Smooth scrolling when switching tabs

G. ERROR HANDLING:
- Form validation before generating report
- Confirmation dialog for reset

H. EXTENSION POINTS:
- Additional languages for internationalization
- Custom templates for different industries
- Integration with other tools (FMEA, Control Plan, etc.)

================================================================================
TOOL 1: CONTROL PLAN CREATOR
================================================================================

APPLICATION OVERVIEW:
This is an interactive Control Plan Creator tool that allows users to create and manage manufacturing control plans following APQP principles.
The tool provides a table-based interface for defining process steps, control characteristics, specifications, evaluation methods, and reaction plans.

KEY COMPONENTS:

1. DATA INPUT SYSTEM:
- Interactive table with rows for each process step
- Columns: Process Name, Machine/Tool, Characteristic, Spec/Tolerance, Evaluation Technique, Sample Size/Freq, Control Method, Reaction Plan, Action
- Textareas for free text input with auto-expand functionality
- Dropdowns for predefined options in Evaluation Technique, Control Method, and Reaction Plan
- Add Row button to create new process steps
- Delete button on each row to remove process steps

2. PRE-DEFINED OPTIONS:
- Evaluation Techniques: Visual Inspection, Digital Caliper, Micrometer, Go/No-Go Gauge, CMM, Profilometer, Coating Thickness Gauge, Torque Wrench
- Control Methods: SPC Chart, First-off Inspection, 100% Inspection, Operator Checklist, Attribute Chart, Destructive Testing, Process Audit
- Reaction Plans: Stop Process & Quarantine, Adjust Machine/Tool, Notify Supervisor, Sort Suspect Material, Re-work/Repair Part, Check Tooling for Wear, Initiate 8D Report

3. EXAMPLE AND RESET:
- Load Example button populates table with sample manufacturing data
- Reset All button clears the entire table
- Example data includes 5 process steps covering different manufacturing operations

4. EXPORT FUNCTIONALITY:
- Export to Excel button generates XLSX file with complete control plan
- Excel file includes title, generation date, and formatted table
- Column widths optimized for readability

5. UI STRUCTURE:
- Wizard-style tabs: Theory & Info, Control Plan Tool, Results
- Responsive design for all device sizes
- Main action buttons (Load Example, Reset All) above tabs
- Horizontal scrollable table for mobile devices

HOW TO INTERACT WITH THE JAVASCRIPT:

A. INITIALIZATION:
- The application loads with one empty row by default
- Event listeners are set up for buttons and table interactions
- Predefined arrays for dropdown options (evaluationTechniques, controlMethods, reactionPlans)
- Example data array for demonstration

B. CORE FUNCTIONS:

1. createRow(data = {})
   - Creates a new row in the table with provided data or empty fields
   - Inserts textareas for free text fields
   - Creates dropdowns for predefined option fields
   - Attaches event listeners for auto-expanding textareas and delete button

2. autoGrow(element)
   - Automatically adjusts the height of textareas based on content
   - Called on input event for all textareas

3. createSelect(options, selectedValue)
   - Creates dropdown select element with provided options
   - Sets selected value if provided

4. loadExample()
   - Clears existing table rows
   - Iterates through exampleData array to create rows
   - Switches to Control Plan Tool tab after loading

5. resetPlan()
   - Clears all rows from the table
   - Creates one empty row by default

6. listResults()
   - Displays current control plan in formatted table in Results tab
   - Creates read-only table showing all entered data
   - Handles empty table case

7. exportToExcel()
   - Uses SheetJS library to create Excel workbook
   - Formats Excel with merged cells for title and date
   - Sets appropriate column widths
   - Downloads file as "Control_Plan_Sigma_Exacta.xlsx"

8. switchWizardTab(tabId)
   - Switches between wizard tabs (Theory, Tool, Results)
   - Updates active tab styling
   - Smooth scroll to top

C. DATA FLOW:
1. User adds rows via Add Row button or loads example
2. User edits textareas or selects from dropdowns
3. Textareas auto-expand based on content
4. User can delete individual rows
5. Results tab shows current data in read-only format
6. Export creates Excel file with all current data

D. UI UPDATES:
- Table dynamically updates as rows are added or removed
- Results tab shows formatted table of current data
- Tabs switch with fade animation
- Mobile devices show horizontally scrollable table

E. EXPORT FUNCTIONALITY:
- Excel file includes:
  * Title row (merged cells across all columns)
  * Generation date row (merged cells)
  * Table headers
  * All rows of data with current values
  * Column widths set based on header length

IMPORTANT ALGORITHMS:

1. EXCEL GENERATION:
- Uses SheetJS XLSX.utils.aoa_to_sheet() for array to sheet conversion
- Merges cells for title and date rows using ws['!merges']
- Sets column widths using ws['!cols']

2. AUTO-GROWING TEXTAREAS:
- element.style.height = 'auto'
- element.style.height = (element.scrollHeight) + 'px'

3. TABLE MANAGEMENT:
- Dynamic row creation with template-based approach
- Event delegation for delete buttons

EDGE CASE HANDLING:
- Empty table handling in listResults()
- Mobile responsive table with horizontal scrolling
- Special characters in Excel export

INTEGRATION POINTS:
1. Header loaded dynamically from header.html
2. SheetJS for Excel export
3. Font Awesome for icons
4. Google Fonts for typography

PERFORMANCE CONSIDERATIONS:
- Table can handle hundreds of rows efficiently
- Excel export optimized for performance
- Event delegation used for efficient event handling

ERROR HANDLING:
- Basic error handling for Excel export
- Graceful handling of empty tables
- Robust input handling in textareas

URL PARAMETER SUPPORT:
- Generic parameter injection via Query Handler
- Support for field-specific parameter names
- Auto-population of form fields from URL parameters

================================================================================
TOOL 2: PROCESS CAPABILITY CALCULATOR
================================================================================

APPLICATION OVERVIEW:
This is a comprehensive Process Capability Calculator (Cp, Cpk, Pp, Ppk) with statistical testing and visualization capabilities.
The application allows users to analyze process data against specification limits to determine process capability.

KEY COMPONENTS:

1. DATA INPUT SYSTEM:
- Multiple datasets can be added/removed dynamically
- Each dataset requires numeric measurements (comma/space separated)
- Common specification limits (LSL, USL, Target) apply to all datasets
- Example datasets are provided for demonstration

2. CALCULATION ENGINE:
- Short-term indices (Cp, Cpk, Cpm) use moving range method (σ_within)
- Long-term indices (Pp, Ppk) use standard deviation (σ_overall)
- Professional normality tests (Shapiro-Wilk, Kolmogorov-Smirnov, Anderson-Darling)
- Defect rate calculation in PPM and percentage

3. VISUALIZATION SYSTEM:
- Process distribution plots with normal curve overlay
- Individuals control charts (I-Charts)
- Separate visualizations for individual datasets and overall performance

4. UI STRUCTURE:
- Wizard-style tabs: Theory, Calculator, Results, Formulas
- Responsive design for all device sizes
- Interactive dataset management

5. URL PARAMETER SUPPORT:
- data: Comma-separated measurements
- lsl: Lower Specification Limit
- usl: Upper Specification Limit
- target: Target value
- type: Calculation type
- auto_calculate: Trigger for automatic calculation

HOW TO INTERACT WITH THE JAVASCRIPT:

A. INITIALIZATION:
- The application loads with one dataset by default
- Event listeners are set up for form submission, buttons, etc.
- Chart.js and KaTeX are loaded from CDN

B. CORE FUNCTIONS:

1. calculateStatistics(data, lsl, usl, target)
   - Main calculation function
   - Returns object with all capability indices and test results
   - Handles edge cases (zero variance, identical values)

2. parseMeasurements(text)
   - Converts text input to numeric array
   - Supports comma, space, or semicolon separation

3. normality test functions:
   - shapiroWilkTest(data) - Professional implementation
   - kolmogorovSmirnovTest(data) - With Stephens correction
   - andersonDarlingTest(data) - Stephens, 1974 implementation

4. visualization functions:
   - plotChart() - Creates process distribution plot
   - createControlChart() - Creates I-Chart
   - plotOverallChart() and createOverallControlChart() for combined data

5. utility functions:
   - normalCDF(x) - High-precision normal CDF (Hart algorithm)
   - normalQuantile(p) - High-precision inverse normal (Acklam's algorithm)

C. DATA FLOW:
1. User inputs data → parseMeasurements() converts to array
2. Form submission → calculateStatistics() processes each dataset
3. Results stored in 'datasets' array and 'overallStats' object
4. Visualizations generated using Chart.js
5. Results displayed in appropriate tabs

D. UI UPDATES:
- updateDatasetTabs() creates tabs for each dataset + overall
- displayResults() shows individual dataset results
- displayOverallResults() shows combined analysis
- All charts are responsive and update dynamically

E. EXPORT FUNCTIONALITY:
- exportToExcel() creates XLSX file with two sheets:
  * Summary sheet with all calculated indices
  * Raw data sheet with all measurements

F. URL PARAMETER INTEGRATION:
- Query Handler automatically injects data, LSL, USL, target values
- Auto-calculation triggered when auto_calculate parameter is set
- Field mapping for common parameter names

IMPORTANT ALGORITHMS:

1. SHORT-TERM SIGMA CALCULATION:
σ_within = MR_bar / 1.128 (where 1.128 is d2 for n=2)
MR_bar = average of moving ranges between consecutive points

2. NORMALITY TESTS:
- All tests use standardized implementations from statistical literature
- Include sample size corrections and accurate p-value calculations
- Return 'Pass' (p > 0.05) or 'Fail' (p ≤ 0.05) results

3. DEFECT CALCULATION:
Uses normal distribution probabilities based on distance from limits

EDGE CASE HANDLING:
- Zero variance datasets (all identical values)
- Extremely large or small datasets
- Invalid specification limits (USL ≤ LSL)
- Insufficient data points (<2 for calculations, <3 for normality tests)

INTEGRATION POINTS:
1. Header loaded dynamically from header.html
2. Chart.js with annotation plugin for visualizations
3. KaTeX for mathematical formula rendering
4. SheetJS for Excel export
5. Query Handler for URL parameter support

PERFORMANCE CONSIDERATIONS:
- Algorithms optimized for up to 5000 data points
- Charts destroy and recreate instead of updating for simplicity
- Calculations run synchronously but are efficient

ERROR HANDLING:
- Input validation with descriptive alerts
- Graceful handling of edge cases
- Fallback values for undefined calculations

================================================================================
TOOL 3: TOLERANCE STACK-UP ANALYSIS
================================================================================

APPLICATION OVERVIEW:
This is a comprehensive Tolerance Stack-Up Analysis tool that calculates the cumulative effect of dimensional variations in an assembly.
The tool supports multiple distribution types for components and uses arithmetic (worst-case), probabilistic (RSS), and Monte Carlo simulation methods.

KEY COMPONENTS:

1. DATA INPUT SYSTEM:
- Multiple dimensions can be added/removed dynamically
- Each dimension requires a nominal value and distribution type
- Supported distributions: Normal, Homogeneous (Uniform), Triangular, Weibull, Lognormal, Beta, Exponential
- For Normal distribution, parameters can be defined by tolerance limits, standard deviation, or Cpk
- Each dimension has a sign (+ or -) to indicate direction in the stack

2. CALCULATION ENGINE:
- Arithmetic method: sums nominal values and tolerances in worst-case scenario
- Probabilistic method: uses Root Sum Square (RSS) for all-normal distributions
- Monte Carlo simulation: used when any non-normal distribution is present
- Intelligent validation system checks distribution parameters

3. VISUALIZATION SYSTEM:
- Vector diagram showing the stack-up of dimensions
- Distribution chart for Monte Carlo results
- Toggle between horizontal and vertical orientation

4. UI STRUCTURE:
- Wizard-style tabs: Theory, Calculator, Results, Formulas
- Responsive design for all device sizes
- Interactive dimension management

HOW TO INTERACT WITH THE JAVASCRIPT:

A. INITIALIZATION:
- The application loads with no dimensions by default
- Event listeners are set up for form controls, buttons, etc.
- Chart.js is loaded for visualizations

B. CORE FUNCTIONS:

1. addDimension(name, nominal, tolerance, distribution, normalParams, sign, specificParams)
   - Adds a new dimension to the analysis
   - Parameters can be customized or left to defaults

2. calculate()
   - Main calculation function
   - Performs validation, then runs arithmetic, probabilistic, and/or Monte Carlo calculations
   - Updates results and visualizations

3. updateVisualization()
   - Redraws the vector diagram based on current dimensions

4. loadExampleData()
   - Loads a set of example dimensions with various distributions

5. resetData()
   - Clears all dimensions and results

6. listResults()
   - Displays detailed calculation history

7. exportToExcel()
   - Exports the calculation history to an Excel file

C. SUPPORTING FUNCTIONS:

1. DistributionValidator class
   - Validates parameters for each distribution type
   - Provides real-time feedback on parameter validity

2. Statistical sampling functions:
   - getRandomNormal(), getRandomUniform(), getRandomTriangular()
   - getRandomWeibull(), getRandomLognormal(), getRandomBeta(), getRandomExponential()

3. Mathematical functions:
   - gamma() - Accurate gamma function implementation
   - boxMullerTransform() - For normal distribution sampling

D. DATA FLOW:
1. User adds dimensions → each dimension is stored in the dimensions array
2. User clicks Calculate → calculate() processes all dimensions
3. Results are stored in calculationHistory array
4. Visualizations are updated

E. VALIDATION SYSTEM:
- DistributionValidator class validates parameters for each distribution
- Real-time validation provides feedback on parameter errors or warnings
- Calculation proceeds only if all dimensions are valid

IMPORTANT ALGORITHMS:

1. MONTE CARLO SIMULATION:
- Generates random samples from each dimension's distribution
- Sums samples according to dimension signs
- Calculates statistics from the resulting distribution

2. ROOT SUM SQUARE (RSS):
- σ_total = √(Σ σ_i²) for all dimensions
- Assumes all dimensions follow normal distribution
- More realistic than worst-case analysis

3. DISTRIBUTION SAMPLING:
- Box-Muller transform for normal distribution
- Inverse transform for uniform and triangular
- Acceptance-rejection for Beta distribution

EDGE CASE HANDLING:
- Zero or negative parameters for distributions that require positive values
- Invalid ranges (e.g., min >= max)
- Insufficient data for calculations
- Numerical instability in gamma function calculations

INTEGRATION POINTS:
1. Header loaded dynamically from header.html
2. Chart.js for visualizations
3. SheetJS for Excel export
4. KaTeX for mathematical formula rendering in Formulas tab

PERFORMANCE CONSIDERATIONS:
- Monte Carlo simulation uses up to 1,000,000 samples (configurable)
- Efficient algorithms for vector diagram rendering
- Calculations run synchronously but are optimized for performance

================================================================================
TOOL 4: WEIBULL ANALYSIS FOR FAILURE PREDICTION
================================================================================

APPLICATION OVERVIEW:
This is a Weibull Analysis tool for reliability engineering that calculates Weibull parameters from failure time data.
The tool performs probability plotting, calculates Mean Time To Failure (MTTF), and predicts failure probabilities at specific times.

KEY COMPONENTS:

1. DATA INPUT SYSTEM:
- Single textarea for entering failure times (comma-separated)
- Optional field for predicting failure probability at a specific time
- Auto-expanding textarea for better user experience
- Example data loading for demonstration

2. CALCULATION ENGINE:
- Weibull parameter estimation (Beta β, Eta η) using probability plotting method
- Mean Time To Failure (MTTF) calculation using Gamma function
- Failure probability prediction at user-specified times
- Gamma function implementation using Lanczos approximation

3. VISUALIZATION SYSTEM:
- Weibull probability plot with log-scale x-axis
- Data points and regression line visualization
- Aggregated results display in card format
- Interactive chart with tooltips

4. UI STRUCTURE:
- Wizard-style tabs: Theory & Info, Calculator Tool, Results, Formulas
- Main action buttons (Load Example, Reset All) above tabs
- Responsive design with full-width layout
- Results visibility toggle

5. URL PARAMETER SUPPORT:
- data: Comma-separated failure times
- auto_calculate: Trigger for automatic calculation

HOW TO INTERACT WITH THE JAVASCRIPT:

A. INITIALIZATION:
- The application loads with empty input fields
- Event listeners are set up for form submission, buttons, etc.
- Chart.js, SheetJS, and KaTeX are loaded from CDN
- Empty chart is initialized

B. CORE FUNCTIONS:

1. calculateWeibull()
   - Main calculation function triggered by form submission
   - Parses failure times, validates input (minimum 2 points)
   - Performs median rank estimation and linear regression
   - Calculates Weibull parameters and MTTF
   - Updates results and visualizations

2. gamma(z)
   - Implements Lanczos approximation for Gamma function
   - Used for accurate MTTF calculation

3. plotChart(points, slope, intercept)
   - Creates Weibull probability plot with Chart.js
   - Shows data points and regression line
   - Uses logarithmic scale for x-axis

4. addResultToList()
   - Adds current analysis to aggregated results list
   - Creates result cards with timestamp and parameters
   - Enables export functionality

5. exportExcel()
   - Exports aggregated results to Excel using SheetJS
   - Includes headers and formatted data

C. DATA FLOW:
1. User enters failure times → parse and validate
2. Form submission → calculateWeibull() processes data
3. Results displayed in Results tab
4. User can add to aggregated list
5. Export creates Excel file with all aggregated analyses

D. UI UPDATES:
- Auto-expanding textarea adjusts to content
- Results become visible after calculation
- Chart updates with data points and regression line
- Aggregated results displayed as cards
- Tabs switch with smooth animation

E. EXPORT FUNCTIONALITY:
- exportExcel() creates XLSX file with aggregated results
- Includes calculation ID, timestamp, failure data, and parameters
- Custom headers and formatting

F. URL PARAMETER INTEGRATION:
- Query Handler injects failure time data from URL
- Auto-calculation triggered when auto_calculate parameter is set
- Field mapping for data parameter

IMPORTANT ALGORITHMS:

1. WEIBULL PARAMETER ESTIMATION:
- Median rank estimation: (rank - 0.5) / n
- Coordinate transformation: x = ln(t), y = ln(ln(1/(1-F(t))))
- Linear regression on transformed coordinates
- Parameter extraction: β = slope, η = exp(-intercept/slope)

2. GAMMA FUNCTION IMPLEMENTATION:
- Lanczos approximation with 7 coefficients
- Accurate for positive real numbers
- Recursive implementation for values < 0.5

3. PROBABILITY PREDICTION:
- Uses Weibull CDF: F(t) = 1 - exp(-(t/η)^β)
- Converts to percentage for display

EDGE CASE HANDLING:
- Insufficient data (minimum 2 failure times)
- Invalid or non-positive time values
- Empty input fields
- Numerical stability in Gamma function

INTEGRATION POINTS:
1. Header loaded dynamically from header.html
2. Chart.js for probability plot visualization
3. SheetJS for Excel export
4. KaTeX for mathematical formula rendering
5. Font Awesome for icons
6. Query Handler for URL parameter support

PERFORMANCE CONSIDERATIONS:
- Efficient linear regression algorithm
- Optimized chart rendering
- Client-side only processing
- Smooth animations for UI elements

ERROR HANDLING:
- Input validation with descriptive alerts
- Graceful handling of edge cases
- Informative error messages
- Fallback for chart rendering issues

================================================================================
TOOL 5: PDCA CYCLE (PLAN-DO-CHECK-ACT)
================================================================================

APPLICATION OVERVIEW:
This is an interactive PDCA (Plan-Do-Check-Act) Cycle tool, also known as the Deming Wheel or Shewhart Cycle.
It provides a structured framework for continuous improvement projects, allowing users to document each phase of the PDCA cycle and generate comprehensive reports.

KEY COMPONENTS:

1. DATA INPUT SYSTEM:
- Four-phase data collection: Plan, Do, Check, Act
- Each phase has specific input fields:
  • Plan: Problem/Opportunity, Goal/Hypothesis, Action Plan
  • Do: Execution Record, Problems/Observations
  • Check: Data & Results, Analysis
  • Act: Conclusions/Learnings, Next Steps
- Auto-expanding textareas for all input fields
- Tab navigation with subtabs for each PDCA phase

2. VISUALIZATION SYSTEM:
- Interactive PDCA wheel with four color-coded quadrants
- Hover effects and animations on wheel segments
- Rotating center circle icon
- Phase-based content display with smooth transitions

3. REPORTING SYSTEM:
- Consolidated report generation in tabular format
- Color-coded rows for each PDCA phase
- Export to Excel with structured format
- Results table with phase-specific styling

4. UI STRUCTURE:
- Three main tabs: Start & Info, PDCA Tool, Report
- Subtabs within PDCA Tool for each phase (Plan, Do, Check, Act)
- Kano-style main action buttons (Load Example, Reset All)
- Tab navigation buttons between phases
- Responsive design for all device sizes

HOW TO INTERACT WITH THE JAVASCRIPT:

A. INITIALIZATION:
- The application loads with empty input fields
- Event listeners are set up for tab switching, buttons, etc.
- SheetJS library loaded for Excel export
- Global cycleData object initialized

B. CORE FUNCTIONS:

1. switchTab(tabId)
   - Switches between main tabs (Start & Info, PDCA Tool, Report)
   - Updates active tab styling
   - Scrolls to top smoothly
   - Updates textarea heights

2. switchSubTab(subTabId)
   - Switches between PDCA phase subtabs (Plan, Do, Check, Act)
   - Updates active subtab styling
   - Scrolls to subtab content
   - Updates textarea heights

3. autoResizeTextarea(textarea)
   - Automatically adjusts textarea height based on content
   - Called on input for all textareas

4. resetTool()
   - Clears all input fields and resets cycleData object
   - Shows confirmation dialog before resetting
   - Displays notification after reset

5. loadExample()
   - Populates all PDCA phases with example data
   - Demonstrates realistic improvement project scenario
   - Switches to PDCA Tool tab after loading
   - Shows notification after loading

6. generateReport()
   - Gathers data from all PDCA phases into cycleData object
   - Validates that at least Plan phase has data
   - Calls displayResults() to show report
   - Switches to Report tab

7. displayResults()
   - Creates formatted HTML table with all PDCA data
   - Applies phase-specific styling and color coding
   - Includes export button for Excel download
   - Shows results container

8. exportToExcel()
   - Uses SheetJS to create Excel workbook
   - Formats data with headers and phase labels
   - Downloads file as "PDCA_Report_Sigma_Exacta_[date].xlsx"
   - Shows notification after export

9. showNotification(message)
   - Displays temporary notification message
   - Uses CSS animations for slide-in and fade-out
   - Automatically removes after 3 seconds

C. DATA FLOW:
1. User enters data in PDCA phase subtabs or loads example
2. Textareas auto-expand as content is added
3. User navigates between phases using tab buttons
4. Generate Report collects all data into cycleData object
5. Results displayed in formatted table in Report tab
6. Export creates Excel file with structured PDCA report

D. UI UPDATES:
- PDCA wheel quadrants have hover effects and animations
- Tabs and subtabs switch with smooth transitions
- Textareas auto-expand based on content
- Results table shows with color-coded phases
- Notifications provide user feedback

E. VISUALIZATION FEATURES:
- PDCA wheel with four interactive quadrants
- Each quadrant has icon, phase name, and description
- Center circle rotates continuously
- Hover effects include scaling, shadows, and brightness
- Quadrant colors: Plan (blue), Do (orange), Check (green), Act (purple)

IMPORTANT ALGORITHMS:

1. TAB NAVIGATION SYSTEM:
- Manages both main tabs and subtabs
- Maintains active state for proper UI feedback
- Handles smooth scrolling and content updates

2. EXCEL EXPORT FORMATTING:
- Creates structured worksheet with phase headers
- Uses appropriate column widths for readability
- Includes date stamp in filename

3. TEXTAREA AUTO-RESIZING:
- element.style.height = 'auto'
- element.style.height = (element.scrollHeight) + 'px'
- Applied to all textareas on input and tab switch

4. DATA VALIDATION:
- Checks for minimum data before report generation
- Confirms destructive actions (reset)
- Validates example loading when data exists

EDGE CASE HANDLING:
- Empty data validation for report generation
- Confirmation for reset actions
- Graceful handling of missing or invalid data
- Responsive design for various screen sizes

INTEGRATION POINTS:
1. Header loaded dynamically from header.html
2. SheetJS 0.18.5 for Excel export
3. Font Awesome 6.4.0 for icons
4. Google Fonts (Nunito) for typography
5. External CSS for styling

PERFORMANCE CONSIDERATIONS:
- Efficient DOM manipulation for tab switching
- Optimized textarea resizing algorithm
- Smooth animations for PDCA wheel interactions
- Client-side only processing

ERROR HANDLING:
- Input validation with descriptive alerts
- Confirmation dialogs for destructive actions
- Notification system for user feedback
- Graceful degradation for unsupported browsers

EDUCATIONAL VALUE:
- PDCA cycle theory and history (Shewhart, Deming)
- Continuous improvement methodology
- Real-world example of improvement project
- Structured problem-solving approach
- Quality management principles

================================================================================
TOOL 6: TAGUCHI DOE CALCULATOR & ANALYZER
================================================================================

APPLICATION OVERVIEW:
This is a Robust Design (Taguchi Method) tool for Design of Experiments (DOE) using orthogonal arrays.
The tool helps plan and analyze experiments to optimize products and processes for quality, calculating Signal-to-Noise (S/N) ratios, factor effects, ANOVA, and optimal factor levels.

KEY COMPONENTS:

1. DATA INPUT SYSTEM:
- Five main tabs: Start & Info, Setup Experiment, Design & Data, Analysis & Report, Formulas
- Dynamic factor and level management with add/remove functionality
- Orthogonal array selection (L4, L8, L9, L16) with automatic recommendation
- Signal-to-Noise ratio type selection (Smaller/Larger/Nominal is best)
- Interactive data entry table for experimental results
- Example data loading for demonstration

2. CALCULATION ENGINE:
- Orthogonal array generation based on selected design
- Signal-to-Noise ratio calculations per Taguchi formulas
- Factor effects analysis with range calculation
- ANOVA with F-critical value lookup tables
- Optimal factor level determination for robustness
- Predicted outcome calculation based on optimal settings

3. VISUALIZATION SYSTEM:
- Main effects plots for each factor
- Pareto chart of factor importance
- Orthogonal array visualization in tabular format
- ANOVA table with significance indicators
- Executive summary with optimal settings

4. UI STRUCTURE:
- Wizard-style five-tab interface following Kano tool pattern
- Responsive design for all device sizes
- Main action buttons (Load Example, Reset All) above tabs
- Tab navigation buttons between phases
- Notification system for user feedback

5. URL PARAMETER SUPPORT:
- experiment-name: Name of the experiment
- objective: Experiment objective
- response-variable: Name of the response variable
- snr-type: Signal-to-Noise ratio type (Smaller/Larger/Nominal)
- factors: Pipe-separated list of factors (e.g., Factor1|Factor2|Factor3)
- levels: Pipe-separated list of levels for each factor (e.g., Level1,Level2|High,Low|TypeA,TypeB)
- array: Orthogonal array selection (L4, L8, L9, L16)
- results: Comma-separated experimental results (e.g., 10.2,9.8,12.1,11.5)
- target: Target value for nominal-is-best analysis
- auto_calculate: Trigger for automatic calculation

HOW TO INTERACT WITH THE JAVASCRIPT:

A. INITIALIZATION:
- The application loads with empty input fields
- Event listeners are set up for tab switching, buttons, etc.
- TaguchiCalculator module loaded from external JS file
- Chart.js and KaTeX are loaded from CDN
- Global experimentData object initialized

B. CORE FUNCTIONS:

1. switchWizardTab(tabId)
   - Switches between main tabs (Start & Info, Setup Experiment, Design & Data, Analysis & Report, Formulas)
   - Updates active tab styling
   - Scrolls to top smoothly

2. addFactorInput(name, levels)
   - Adds a new factor input row to the setup form
   - Includes name and levels (comma-separated) fields
   - Attaches remove button functionality

3. generateDesign()
   - Validates setup data and generates orthogonal array design
   - Creates interactive data entry table for experimental runs
   - Automatically selects appropriate array if not specified
   - Shows notification upon completion

4. runFullAnalysis()
   - Collects data from design table and validates completeness
   - Calls TaguchiCalculator.runAnalysis() with experiment data
   - Generates comprehensive analysis report with visualizations
   - Switches to Analysis & Report tab

5. createAndDisplayReportBlock(runId)
   - Creates formatted analysis report with multiple sections:
     • Executive summary with optimal settings
     • Effects analysis with Pareto chart
     • Main effects plots for each factor
     • Factor effects tables
     • ANOVA table with significance testing
     • Signal-to-Noise ratio analysis
     • Export functionality

6. createParetoChart(runId)
   - Creates Pareto chart of factor importance using Chart.js
   - Sorts factors by effect range from most to least influential
   - Uses blue color scheme for consistency

7. createMainEffectsCharts(runId)
   - Creates main effects plots for each factor
   - Shows average response at each factor level
   - Uses line charts with different colors for each factor

8. exportToExcelTaguchi(runId)
   - Exports complete Taguchi analysis to Excel using SheetJS
   - Creates multiple sheets: Summary, Design Data, ANOVA
   - Includes all calculated results and settings
   - Downloads file with experiment name in filename

C. DATA FLOW:
1. User sets up experiment with factors and levels
2. Generate Design creates orthogonal array and data entry table
3. User enters experimental results for each run
4. Calculate Full Analysis processes data through TaguchiCalculator
5. Results displayed with visualizations in Analysis & Report tab
6. Export creates Excel file with comprehensive analysis

D. TAGUCHICALCULATOR MODULE:
The core calculation logic is encapsulated in the TaguchiCalculator module:

1. Orthogonal Arrays: Predefined L4, L8, L9, L16 arrays
2. Signal-to-Noise Ratio Calculations:
   - Smaller is better: S/N = -10 log10(y²)
   - Larger is better: S/N = -10 log10(1/y²)
   - Nominal is best: S/N = -10 log10((y-T)²)
3. Factor Effects Analysis: Calculates average response per factor level
4. ANOVA Calculation: Computes sum of squares, F-values, significance
5. Optimal Level Determination: Finds levels that maximize S/N ratio
6. F-Critical Values: Lookup table with conservative interpolation

E. URL PARAMETER INTEGRATION:
- Query Handler processes Taguchi-specific parameters
- Special handlers for factors and levels (pipe-separated format)
- Special handler for results (comma-separated values)
- Auto-calculation triggered when auto_calculate parameter is set
- Dynamic factor creation from URL parameters

F. UI UPDATES:
- Dynamic factor management with real-time validation
- Interactive data entry table with change tracking
- Automatic orthogonal array selection based on factors
- Charts update dynamically based on analysis results
- Tab switching with smooth animations
- Notification system for user feedback

IMPORTANT ALGORITHMS:

1. ORTHOGONAL ARRAY SELECTION:
- Automatically selects appropriate array based on:
  • Maximum number of levels among factors
  • Number of factors
- Falls back to manual selection if automatic fails

2. SIGNAL-TO-NOISE RATIO CALCULATIONS:
- Follows Taguchi's formulas for different quality characteristics
- Handles edge cases (zero values, null results)
- Converts to dB scale for interpretation

3. FACTOR EFFECTS ANALYSIS:
- Calculates average response for each factor level
- Computes range (max-min) to determine factor importance
- Uses orthogonal array structure for proper averaging

4. ANOVA CALCULATION:
- Computes sum of squares for factors and error
- Calculates degrees of freedom
- Looks up F-critical values with conservative interpolation
- Determines statistical significance (p < 0.05)

5. OPTIMAL LEVEL DETERMINATION:
- Selects levels that maximize Signal-to-Noise ratio
- Associates response values with optimal levels
- Calculates predicted outcome based on optimal settings

6. URL PARAMETER PROCESSING:
- Parses pipe-separated factors and levels
- Maps comma-separated results to response inputs
- Validates parameter formats before processing

EDGE CASE HANDLING:
- Missing or invalid response data validation
- Conservative F-critical value interpolation when exact DF not available
- Handling of nominal target when S/N type is nominal
- Automatic orthogonal array fallback when manual selection invalid
- Mobile-responsive data entry table
- URL parameter format validation and error handling

INTEGRATION POINTS:
1. Header loaded dynamically from header.html
2. TaguchiCalculator module for core calculations
3. Chart.js for visualizations (Pareto, main effects)
4. SheetJS for Excel export
5. KaTeX for mathematical formula rendering in Formulas tab
6. Font Awesome for icons
7. Query Handler for URL parameter support

PERFORMANCE CONSIDERATIONS:
- Efficient orthogonal array processing
- Optimized chart rendering with Chart.js
- Client-side only calculations
- Smooth tab switching without page reloads
- Efficient URL parameter parsing

ERROR HANDLING:
- Comprehensive input validation with descriptive alerts
- Graceful handling of incomplete data
- Notification system for user feedback
- Fallback for chart rendering issues
- Conservative statistical calculations to avoid errors
- URL parameter validation and error messages

EDUCATIONAL VALUE:
- Taguchi Method theory and history (Genichi Taguchi)
- Orthogonal array design principles
- Signal-to-Noise ratio concepts for quality engineering
- Robust design methodology for process optimization
- ANOVA and statistical significance in experimental design
- Real-world example of experimental design and analysis
- URL parameter techniques for data sharing and collaboration

================================================================================
TOOL 7: FMEA (FAILURE MODE AND EFFECTS ANALYSIS)
================================================================================

APPLICATION OVERVIEW:
This is a Failure Mode and Effects Analysis (FMEA) tool for proactively identifying and mitigating potential failures in designs (DFMEA) and processes (PFMEA).
The tool follows the modern AIAG & VDA 7-Step FMEA process, focusing on Structure, Function, and Failure Analysis steps.
Users can define system components, contacts (interfaces), and functions, visualize the system structure with an interactive network diagram, and generate FMEA tables to analyze failure modes, effects, causes, and controls with automatic Risk Priority Number (RPN) calculation.

KEY COMPONENTS:

1. DATA INPUT SYSTEM:
- Three main data panels: Components, Contacts, and Functions
- Components can be marked as external (outside system boundary)
- Contacts define interfaces between components (from-to relationships)
- Functions describe what the system is supposed to do and are assigned to specific contacts
- Functions can be primary or secondary

2. VISUALIZATION SYSTEM:
- Interactive network diagram (using vis.js) showing components as nodes and contacts as edges
- Functions are displayed as colored curved arrows overlaid on contacts
- Internal and external components are visually distinguished
- Users can drag nodes to rearrange the layout
- Legend shows function colors and labels

3. FMEA ANALYSIS SYSTEM:
- Generate FMEA button creates a new analysis instance
- Each function gets a row in the FMEA table with ability to add multiple failure modes
- For each failure mode, users can define: failure mode, effects, severity (S), causes, occurrence (O), current controls, detection (D)
- RPN is automatically calculated as S × O × D and color-coded (high ≥100, medium ≥50)
- Recommended actions can be added for each failure mode
- Each analysis instance is timestamped and can be exported separately

4. UI STRUCTURE:
- Wizard-style tabs: Theory & Info, Define Structure, Visualize, FMEA Results
- Main action buttons (Load Example, Reset All) above tabs
- Responsive design for all device sizes

HOW TO INTERACT WITH THE JAVASCRIPT:

A. INITIALIZATION:
- The application loads with empty data structures
- Event listeners are set up for buttons and form controls
- vis.js and SheetJS are loaded from CDN

B. CORE FUNCTIONS:

1. loadExample()
   - Populates components, contacts, and functions with example data
   - Switches to Define Structure tab after loading

2. resetAll()
   - Clears all data and resets counters
   - Destroys and recreates the network visualization

3. addComponent(), addContact(), addFunction()
   - Validate input and add new items to respective arrays
   - Update all displays and visualizations

4. updateAll()
   - Updates the components, contacts, and functions lists
   - Updates the network visualization

5. updateNetworkVisualization()
   - Creates or updates the vis.js network
   - Internal components are placed in the center, external components above and below
   - Contacts are drawn as straight lines, functions as curved arrows with labels

6. generateFMEA()
   - Creates a new FMEA analysis block with a timestamp
   - For each function, creates a table row with input fields for failure analysis
   - Adds event listeners for dynamic RPN calculation and action management

7. exportTableToExcel(tableElement, fileName)
   - Exports the FMEA table to an Excel file using SheetJS
   - Includes all failure mode data and recommended actions

8. exportChart()
   - Exports the network diagram as a JPG image

C. DATA FLOW:
1. User adds components, then contacts between components, then functions assigned to contacts
2. The network diagram updates in real-time
3. User clicks Generate FMEA to create a new analysis table
4. In the table, user fills in failure modes, effects, causes, controls, and selects S, O, D values
5. RPN is calculated automatically and color-coded
6. User can add recommended actions for each failure mode
7. User can export the FMEA table to Excel or export the network diagram as an image

D. UI UPDATES:
- Lists of components, contacts, and functions update as items are added or removed
- Network diagram updates dynamically
- New FMEA analysis blocks are added to the Results tab with smooth scrolling

E. EXPORT FUNCTIONALITY:
- Each FMEA analysis can be exported to Excel with formatted columns
- Network diagram can be exported as JPG

IMPORTANT ALGORITHMS:

1. NETWORK LAYOUT:
- Internal components are arranged in two columns with vertical spacing
- External components are placed above and below the internal zone with horizontal spacing
- Contacts are drawn as straight lines, functions as curved arrows to avoid overlap

2. RPN CALCULATION:
- RPN = Severity × Occurrence × Detection
- Color coding: red for RPN ≥100, yellow for RPN ≥50, no color otherwise

3. DYNAMIC TABLE MANAGEMENT:
- Rows are added dynamically for each failure mode
- Textareas auto-expand based on content
- Action items can be added or removed dynamically

EDGE CASE HANDLING:
- Preventing duplicate or self-contacts
- Handling deletion of components that are referenced by contacts or functions
- Validating input before adding new items
- Handling empty data sets in visualization

INTEGRATION POINTS:
1. Header loaded dynamically from header.html
2. vis.js for network visualization
3. SheetJS for Excel export
4. Font Awesome for icons
5. Google Fonts for typography

PERFORMANCE CONSIDERATIONS:
- Network visualization is optimized for up to 50 nodes and edges
- Dynamic table rows are added efficiently with event delegation

ERROR HANDLING:
- Input validation with alerts for invalid data
- Graceful handling of missing data in exports

EDUCATIONAL VALUE:
- Explains FMEA methodology and 7-step process
- Provides example data for a mechanical system
- Teaches risk assessment through RPN calculation

================================================================================
TOOL 8: QUALITY FUNCTION DEPLOYMENT (QFD)
================================================================================

APPLICATION OVERVIEW:
This is an interactive Quality Function Deployment (QFD) tool, centered around the "House of Quality" matrix.
It enables users to translate Customer Needs ("Whats") into Technical Specifications ("Hows"), prioritize engineering efforts, and analyze the relationships and correlations between them to ensure the voice of the customer drives the design process.

KEY COMPONENTS:

1. DATA INPUT SYSTEM:
- Four specialized input tabs within the "Input Data" section:
  • Customer Needs: Text input with Importance rating (1-5 scale)
  • Technical Specs: Measurable engineering characteristics
  • Relationships: Matrix defining link strength between Needs and Specs (Strong/Medium/Weak/None)
  • Correlations: "Roof" matrix defining interactions between Technical Specs (Strong Positive/Positive/Negative/Strong Negative)
- Dynamic lists with add/remove functionality for requirements and specs

2. VISUALIZATION SYSTEM:
- House of Quality Matrix generation including:
  • The "Roof" (Correlation Matrix)
  • The "Room" (Relationship Matrix with symbols: ●, ○, ▲)
  • The "Basement" (Technical Priorities and Rankings)
- Priority bar charts for visual comparison of technical importance

3. CALCULATION ENGINE:
- Priority Score Calculation: Sum of (Customer Importance × Relationship Value)
- Dynamic Ranking: Auto-ranks technical specs based on calculated scores
- Rank-based color coding (Red for top rank, fading to grey)

4. UI STRUCTURE:
- Wizard-style main tabs: Theory & Info, Input Data, Results & Matrix
- Nested tabs within Input Data for organized data entry
- Responsive design with horizontal scrolling for large matrices
- Action buttons (Load Example, Reset All, Generate Matrix)

HOW TO INTERACT WITH THE JAVASCRIPT:

A. INITIALIZATION:
- The application loads with empty arrays for customerRequirements and technicalRequirements
- Objects `relationships` and `correlations` are initialized
- Event listeners set up for all input buttons and tab switching

B. CORE FUNCTIONS:

1. switchQfdTab(tabId) / switchInputTab(tabId)
   - Handles navigation between main wizard tabs and nested input tabs
- Updates active states and scrolls to content

2. renderCustomerRequirements() / renderTechnicalSpecs()
   - Dynamically updates the DOM lists as items are added/removed
   - Handles "empty state" messages

3. updateRelationshipControls()
   - Generates the relationship selection grid based on current needs and specs
   - Uses data attributes to map inputs to specific pairs (cr_ID + tr_ID)

4. updateCorrelationControls()
   - Generates the triangular correlation grid for the "Roof"
   - Prevents redundant pairs (only shows upper triangle of matrix)

5. generateQfdMatrix()
   - Constructs the full House of Quality HTML table
   - Renders symbols for relationships (●=9, ○=3, ▲=1)
   - Renders signs for correlations (++, +, -, --)
   - Triggers priority calculation

6. calculatePriorities()
   - Computes technical scores and updates the "Basement" of the matrix
   - Generates the priority summary table with bar charts

7. loadExample()
   - Populates the tool with a complete dataset (6 needs, 6 specs)
   - Sets up complex relationships and correlations
   - Switches view to Input Data tab

8. exportToExcel()
   - Uses SheetJS to export the matrix and priority list
   - Formats column widths for readability

C. DATA FLOW:
1. User inputs Needs and Specs -> Arrays updated -> Render Lists
2. User defines Relationships/Correlations -> Objects updated
3. User clicks Generate -> `generateQfdMatrix` builds DOM table
4. `calculatePriorities` runs math -> Updates table footer and Results tab

D. UI UPDATES:
- Toast notifications (`showToast`) for actions (add, remove, error, success)
- Smooth scrolling when switching tabs or generating matrix
- Dynamic table generation for the matrix

E. EXPORT FUNCTIONALITY:
- Exports two sheets:
  * "QFD Matrix": The visual representation of the House
  * "Priorities": Sorted list of technical specs with scores and ranks

IMPORTANT ALGORITHMS:

1. PRIORITY SCORE CALCULATION:
- Score(Tech_Spec_j) = Σ (Customer_Importance_i × Relationship_Value_ij)
- Relationship Values: Strong (9), Medium (3), Weak (1), None (0)

2. RANKING LOGIC:
- Sorts Technical Specs by Score (Descending)
- Assigns Rank 1 to highest score
- Handles ties (same rank for identical scores)

3. MATRIX CONSTRUCTION:
- "Roof" Logic: Iterates `i` from 0 to N, `j` from `i+1` to N to build the triangular correlation structure

EDGE CASE HANDLING:
- Attempting to generate matrix with 0 needs or 0 specs
- Attempting to set correlations with < 2 technical specs
- Empty relationship values treated as 0 in calculation

INTEGRATION POINTS:
1. Header loaded from header.html
2. SheetJS (xlsx.full.min.js) for Excel export
3. Font Awesome for UI icons and matrix symbols
4. Google Fonts (Nunito)

PERFORMANCE CONSIDERATIONS:
- Matrix generation clears and rebuilds DOM elements
- Responsive horizontal scrolling for mobile viewing of large matrices

ERROR HANDLING:
- Toast notifications for missing input data
- Input validation to prevent empty text entries
- Confirmation dialog for Reset All action

EDUCATIONAL VALUE:
- Visualizes the House of Quality methodology
- Demonstrates the flow from Voice of Customer to Engineering Specs
- Teaches prioritization based on weighted impact

================================================================================
TOOL 9: PUGH MATRIX CREATOR
================================================================================

APPLICATION OVERVIEW:
This is an interactive Pugh Matrix (Decision Matrix) tool used to systematically evaluate and select the best concept from a list of alternatives.
It uses a weighted criteria system where concepts are compared against a designated "Baseline" (or Datum) concept, scoring them as Better (+), Same (S), or Worse (-).

KEY COMPONENTS:

1. DATA INPUT SYSTEM:
- Two dynamic list builders:
  • Criteria: The requirements used to judge concepts (e.g., Cost, Weight)
  • Concepts: The different alternatives being evaluated
- Add/Remove functionality for list items
- Validation ensures at least 1 criterion and 2 concepts before generation

2. MATRIX SYSTEM:
- Dynamic table generation based on input lists
- Baseline Selector: Dropdown to choose which concept serves as the reference (Datum)
- Weights: Numeric input for each criterion to determine importance
- Scoring: Dropdown per cell (+, S, -) to compare concepts against the baseline

3. CALCULATION ENGINE:
- Score Mapping: "+" = 1, "S" = 0, "-" = -1
- Total Score Calculation: Σ (Score × Weight) for each concept
- Baseline Logic: The baseline concept always scores 0 for all criteria
- Automatic Winner Detection: Highlights the concept with the highest total score

4. UI STRUCTURE:
- Wizard-style tabs: Theory & Info, Data Input & Matrix, Results
- Integrated matrix view within the Data Input tab for real-time interaction
- Results tab with summary view and "Winning Concept" highlight card
- Main action buttons (Load Example, Reset All)

HOW TO INTERACT WITH THE JAVASCRIPT:

A. INITIALIZATION:
- Loads header from header.html
- Initializes empty `criteriaData` and `conceptsData` arrays
- Sets up global listeners for navigation and main buttons

B. CORE FUNCTIONS:

1. generateMatrix()
   - Constructs the HTML table string based on input arrays
   - Creates dropdowns for Baseline selection and scoring
   - Attaches event listeners to new inputs for real-time calculation
   - Updates `matrixGenerated` state

2. updateScores()
   - Main calculation loop triggered on any input change
   - Identifies the current Baseline index
   - Iterates through rows (criteria) and columns (concepts)
   - Sums weighted scores (Score × Weight)
   - Updates the "Total" row in the footer

3. highlightWinner(totals, baselineIndex)
   - Finds the maximum score excluding the baseline
   - Applies CSS classes (`winning-column`, `winning-column-header`) to the winner
   - Handles draws (no winner highlighted if tie)

4. loadExampleData()
   - Populates lists with sample data (e.g., "Standard Plastic Case", "Machined Aluminum Case")
   - Automatically switches to Input tab and saves data

5. exportToExcel()
   - Clones the matrix table
   - Replaces interactive inputs (selects, numbers) with static text values
   - Uses SheetJS `table_to_book` to generate the file

C. DATA FLOW:
1. User adds items to lists -> Arrays updated -> `saveInputData`
2. User clicks Generate Matrix -> Table built in DOM
3. User changes Baseline -> `updateScores` resets baseline column to "S" and recalculates others
4. User adjusts Weights or Scores -> `updateScores` recalculates totals
5. Winner is highlighted dynamically

D. UI UPDATES:
- "Go to Results" button is disabled until matrix is generated
- Baseline cells are visually distinct (blue background, fixed "B" value)
- Winning column gets a green highlight
- Results tab shows a summary card with the winner's name and score

E. ALGORITHMS:
- Weighted Sum: Total = Σ (Weight_i * Score_ij) where Score is {1, 0, -1}
- Baseline enforcement: Logic ensures comparison is always relative to the selected Datum

INTEGRATION POINTS:
1. SheetJS (xlsx.full.min.js) for Excel export
2. Font Awesome for UI icons
3. Header loaded from header.html

EDGE CASE HANDLING:
- Minimum data validation (1 criterion, 2 concepts)
- Handling of ties in winner detection
- Export logic handles complex HTML elements (selects inside cells)

EDUCATIONAL VALUE:
- Teaches the "Datum" concept in decision making
- Demonstrates systematic, weighted evaluation
- Encourages objective comparison over subjective preference

================================================================================
TOOL 10: VAVE ANALYSIS (VALUE ANALYSIS & VALUE ENGINEERING)
================================================================================

APPLICATION OVERVIEW:
This is a Value Analysis and Value Engineering (VAVE) tool designed to optimize product value by systematically analyzing functions and costs.
It enables users to define system structures (components, contacts, functions), visualize them via network diagrams, and perform value calculations (Value Index = Function / Cost) to identify areas for improvement (VA) or optimization during design (VE).

KEY COMPONENTS:

1. DATA INPUT SYSTEM:
- Three main structure panels:
  • Components: Define system parts (Internal or External)
  • Contacts: Define interfaces/connections between components (From/To)
  • Functions: Define what the system does (Primary or Secondary type), assigned to specific contacts
- Dynamic lists with add/remove functionality for all structural elements
- Analysis Input: Cost ($) and Value Score (1-10) for each identified function

2. VISUALIZATION SYSTEM:
- Interactive Network Diagram (using vis.js):
  • Internal components arranged centrally
  • External components arranged above and below
  • Contacts shown as straight lines
  • Functions shown as curved arrows with labels
- Real-time updates as structure is modified
- Export functionality for the diagram as JPG

3. CALCULATION ENGINE:
- Value Index Calculation: Value Score / Cost
- Priority Logic:
  • High Value: Index ≥ 0.25 (Green)
  • Medium Value: Index ≥ 0.1 (Yellow)
  • Low Value: Index < 0.1 (Red - candidates for cost reduction)
- Summary statistics: Total Cost, Average Value Index

4. UI STRUCTURE:
- Wizard-style tabs: Theory & Info, Define Structure, Visualize, VAVE Analysis
- Responsive design with smooth transitions
- Main action buttons (Load Example, Reset All)
- Integrated tab navigation buttons

HOW TO INTERACT WITH THE JAVASCRIPT:

A. INITIALIZATION:
- Loads header from header.html
- Initializes empty arrays: `components`, `contacts`, `functions`
- Sets up global listeners and initializes vis.js network

B. CORE FUNCTIONS:

1. addComponent() / addContact() / addFunction()
   - Validates inputs and adds new objects to respective arrays
   - Updates DOM lists and internal counters
   - Triggers `updateAll()` to refresh UI and Select options

2. updateNetworkVisualization()
   - Configures vis.js data sets (nodes and edges)
   - Implements specific layout logic:
     * Internal nodes: Central grid layout
     * External nodes: Fixed offsets top/bottom
   - Renders functions as curved arrows (`curvedCW`) to distinguish from physical contacts

3. generateVAVEAnalysis()
   - Builds the analysis table dynamically based on defined functions
   - Calculates initial Value Indices
   - Attaches event listeners to Cost and Value Score inputs for real-time recalculation

4. calculateAllVAVEValues()
   - Iterates through all functions
   - Computes Value Index (Score / Cost)
   - Applies CSS classes for High/Medium/Low priority highlighting
   - Updates summary statistics

5. loadExample()
   - Populates the tool with a complete mechanical system (Motor, Gearbox, Controller, etc.)
   - Sets up complex relationships and functions (Transmit Power, Control Speed)
   - Automatically transitions to Structure tab

6. exportVAVEToExcel()
   - Uses SheetJS to export two sheets:
     * "VAVE Analysis": Detailed function data, costs, and scores
     * "Summary": Totals and counts of High/Low value functions

C. DATA FLOW:
1. User defines Structure (Components -> Contacts -> Functions)
2. Network Diagram updates automatically via `updateNetworkVisualization`
3. User proceeds to Analysis tab -> `generateVAVEAnalysis` builds table
4. User inputs Costs and Scores -> Value Index is calculated real-time
5. User exports results or image

D. UI UPDATES:
- Network diagram handles node dragging and fitting
- Dynamic dropdowns in "Define Structure" populate based on existing components/contacts
- Analysis table updates color-coding immediately upon input change

E. ALGORITHMS:
- Network Layout: Custom positioning logic to separate Internal vs External system boundaries
- Value Equation: Value = Function Performance / Lifecycle Cost
- Prioritization thresholds (0.1, 0.25) for visual heat-mapping

INTEGRATION POINTS:
1. vis.js (4.21.0) for Network Visualization
2. SheetJS (xlsx.full.min.js) for Excel export
3. Font Awesome for UI icons
4. Header loaded from header.html

EDGE CASE HANDLING:
- Attempting to add contacts with < 2 components
- Handling Cost = 0 (prevents division by zero errors in display)
- Deletion logic cascades (deleting a component deletes associated contacts and functions)

EDUCATIONAL VALUE:
- Teaches the "Value = Function / Cost" equation
- Visualizes system boundaries and functional interfaces
- Demonstrates the difference between Primary and Secondary functions

================================================================================
TOOL 11: TRIZ PROBLEM SOLVING TOOL & 40 PRINCIPLES
================================================================================

APPLICATION OVERVIEW:
This is a comprehensive TRIZ (Theory of Inventive Problem Solving) tool that implements the full TRIZ methodology for systematic innovation and invention. 
The tool provides an 8-step structured approach to problem solving including LDST analysis, Ideal Final Result formulation, 9 Windows analysis, 
Function Analysis, Technical Contradiction resolution using the Contradiction Matrix, Physical Contradiction resolution using Separation Principles, 
and Su-Field Analysis with 76 Standard Solutions. It combines data-driven methodologies with visual modeling to guide users through the complete TRIZ process.

KEY COMPONENTS:

1. DATA INPUT SYSTEM:
- Three main wizard tabs: Start & Info, TRIZ Tools, Solve & Report
- Eight sub-tabs within TRIZ Tools for systematic problem solving:
  • Define Problem: System, function, and drawback identification
  • LDST Analysis: Laws of Development of Technical Systems selection
  • Formulate IFR: Ideal Final Result definition
  • 9 Windows Analysis: Time and system level analysis matrix
  • Function Analysis: Component interaction mapping with Mermaid diagrams
  • Technical Contradiction: Contradiction Matrix with classic (39x39) and 2003 (48x48) versions
  • Physical Contradiction: Intersection test algorithm with separation principles
  • Su-Field Analysis: Substance-Field modeling with 76 Standard Solutions matrix
- Dynamic component management for Function Analysis
- Interactive matrix visualization for Technical Contradictions

2. CALCULATION ENGINE:
- LDST algorithm mapping system lifecycle stages to development laws
- Technical Contradiction Matrix lookup (Classic 39x39 and 2003 48x48 versions)
- Physical Contradiction resolution algorithm with intersection test
- Su-Field problem classification and Standard Solutions matching
- Function Analysis with Mermaid diagram generation
- Comprehensive solution path generation combining all TRIZ methods

3. VISUALIZATION SYSTEM:
- Interactive Contradiction Matrix with hover effects
- Su-Field diagrams with problem state visualization
- Mermaid diagrams for Function Analysis
- 9 Windows matrix with color-coded cells
- Physical Contradiction flow diagram
- Solution transformation visualizations (Before/After states)

4. UI STRUCTURE:
- Wizard-style main navigation with three primary tabs
- Sub-tab navigation for 8-step TRIZ methodology
- Responsive design optimized for mobile and desktop
- Main action buttons (Load Example, Reset All) above tabs
- Color-coded interface with consistent TRIZ theme

5. URL PARAMETER SUPPORT:
- system: System/Object to improve
- function: Primary useful function
- harm: Main drawback or problem
- ifr: Ideal Final Result formulation
- lifecycle-stage: LDST life cycle stage (birth, growth, maturity, decline, transition)
- conflicting-parameter: Physical contradiction parameter
- intersection-test: Physical contradiction intersection type (no-intersection, contiguous, total-intersection)
- separation-type: Physical contradiction separation type (condition, system-level, neither)
- matrix-version: TRIZ matrix version (classic, 2003)
- improving-feature: Technical contradiction improving feature (1-39 or 1-48)
- worsening-feature: Technical contradiction worsening feature (1-39 or 1-48)
- sufield-object: Su-Field S1 object
- sufield-tool: Su-Field S2 tool
- sufield-field: Su-Field field type
- sufield-type: Su-Field problem type (insufficient, harmful, difficult, missing, excessive, inefficient)
- auto_calculate: Trigger for automatic calculation

HOW TO INTERACT WITH THE JAVASCRIPT:

A. INITIALIZATION:
- The application loads with empty input fields and default values
- Event listeners are set up for tab switching, buttons, form controls
- External TRIZ libraries loaded: trizcontradiction.js, trizcontradiction2003.js, physicalcontradictionprinciples1993.js, 76principlestriz.js, sufield-diagrams.js, ldst.js, trizconstants.js
- Mermaid.js initialized for Function Analysis diagrams
- SheetJS loaded for Excel export functionality
- Global variables initialized: problemData, exampleIndex, improvingFeatureIndex, worseningFeatureIndex, currentMatrixVersion

B. CORE FUNCTIONS:

1. switchMainTab(tabId)
   - Switches between main wizard tabs (Start & Info, TRIZ Tools, Solve & Report)
   - Updates active tab styling and scrolls to top
   - Ensures proper sub-tab visibility when switching to TRIZ Tools

2. switchSubTab(subTabId)
   - Switches between 8 TRIZ methodology sub-tabs
   - Updates active sub-tab styling and content visibility
   - Handles special initialization for Function Analysis and Technical Contradiction tabs

3. init()
   - Main initialization function called after DOM loads
   - Sets default matrix version to classic
   - Populates dropdowns and creates contradiction matrix
   - Initializes LDST recommendations and Su-Field systems

4. loadExampleAndGo()
   - Loads example data and navigates to TRIZ Tools tab
   - Cycles through multiple example scenarios
   - Populates all TRIZ tools with coherent example data

5. resetTool()
   - Resets all input fields to default values
   - Clears results container and resets global variables
   - Returns to Start & Info tab

6. updateLDSTRecommendations()
   - Updates LDST recommendations based on selected lifecycle stage
   - Highlights recommended laws in the laws table
   - Updates recommendation text display

7. changeMatrixVersion()
   - Switches between Classic (39x39) and 2003 (48x48) contradiction matrices
   - Updates dropdowns and matrix visualization
   - Maintains selected contradiction if compatible

8. populateDropdowns()
   - Populates Technical Contradiction dropdowns with features
   - Handles both Classic and 2003 matrix versions
   - Maintains 1-based indexing for user display

9. createContradictionMatrix()
   - Generates interactive contradiction matrix HTML table
   - Includes hover effects and click selection
   - Displays principle numbers in matrix cells

10. selectMatrixCell(row, col)
    - Handles matrix cell selection for Technical Contradiction
    - Updates dropdown values and global indices
    - Highlights selected cell and updates display

11. updatePhysicalStrategy()
    - Implements Physical Contradiction resolution algorithm
    - Processes intersection test and separation type decisions
    - Determines recommended resolution strategy and principles

12. initFunctionAnalysis()
    - Initializes Function Analysis data structures
    - Sets up component management system
    - Prepares Mermaid diagram rendering

13. updateFunctionAnalysis()
    - Updates Function Analysis data from user inputs
    - Regenerates interaction matrix and Mermaid diagram
    - Maintains consistency between components and functions

14. solveProblem()
    - Main solution generation function
    - Collects data from all TRIZ tools
    - Processes contradictions and generates recommendations
    - Calls displayResults() to render comprehensive solution

15. displayResults()
    - Generates comprehensive solution report
    - Combines results from all TRIZ methodologies
    - Includes visualizations and export functionality
    - Renders Mermaid diagrams in results

16. exportToExcel()
    - Exports complete TRIZ analysis to Excel using SheetJS
    - Includes all problem definitions, analyses, and recommendations
    - Formats data with appropriate column widths

C. DATA FLOW:
1. User defines problem → System, function, drawback stored in problemData
2. LDST analysis → Lifecycle stage mapped to development laws
3. IFR formulation → Ideal solution definition stored
4. 9 Windows analysis → Time/system level data captured in matrix
5. Function Analysis → Components, interactions, and functions mapped with Mermaid
6. Technical Contradiction → Matrix selection yields inventive principles
7. Physical Contradiction → Intersection test yields separation principles
8. Su-Field Analysis → Problem classification yields standard solutions
9. Solve Problem → All data combined into comprehensive solution report
10. Export → Complete analysis exported to Excel format

D. UI UPDATES:
- Tab switching with smooth animations and scroll positioning
- Matrix visualization with real-time highlighting
- Function Analysis diagrams update dynamically
- Physical Contradiction flow shows/hides steps based on selections
- Results container expands with comprehensive solution
- Mobile-responsive layouts adapt to screen size

E. EXPORT FUNCTIONALITY:
- Excel export includes all TRIZ analyses in structured format
- Multiple sheets for different analysis types
- Formatted with appropriate column widths and headers
- Timestamp and tool version included in filename

IMPORTANT ALGORITHMS:

1. LDST MAPPING ALGORITHM:
- Maps system lifecycle stages to appropriate development laws
- Birth → Law 4 (Ideality), Law 1 (System Integrity)
- Growth → Law 5 (Uneven Development), Law 2 (Energy Conductivity)
- Maturity → Law 3 (Harmony), Law 6 (Transition to Supersystem)
- Decline → Law 7 (Transition to Micro-Level), Law 8 (Increased S-Field Complexity)
- Transition → Law 4 (Ideality), Law 6 (Transition to Supersystem)

2. TECHNICAL CONTRADICTION MATRIX LOOKUP:
- Uses 1-based indexing for both Classic (1-39) and 2003 (1-48) matrices
- Matrix cell lookup returns array of principle numbers
- Cross-references principle numbers with detailed descriptions
- Handles edge cases (invalid indices, empty results)

3. PHYSICAL CONTRADICTION RESOLUTION ALGORITHM:
- Step 1: Intersection Test (Space/Time analysis)
  • No intersection → Separation in Space AND Time
  • Contiguous → Satisfy contradictory demands
  • Total intersection → Proceed to Step 2
- Step 2: Separation Type analysis
  • Condition → Separation in Relation
  • System-level → Separation in System Level
  • Neither → Bypass contradictory demands
- Maps decisions to specific separation principle categories

4. FUNCTION ANALYSIS DIAGRAM GENERATION:
- Uses Mermaid.js for interactive diagram rendering
- System components: Blue rectangles
- Supersystem components: Orange hexagons
- Target component: Yellow rounded rectangle
- Useful functions: Solid/dashed lines based on performance
- Harmful functions: Red thick lines
- Dynamic label generation based on component relationships

5. SU-FIELD PROBLEM CLASSIFICATION:
- Six problem types: insufficient, harmful, difficult, missing, excessive, inefficient
- Maps to 76 Standard Solutions through solutionMap object
- Visual indication through different line styles and colors
- Before/After state visualization for solution transformation

EDGE CASE HANDLING:
- Empty or invalid input validation with descriptive messages
- Matrix index boundary checking for both Classic and 2003 versions
- Physical Contradiction algorithm handles incomplete decision paths
- Function Analysis handles empty component lists gracefully
- Su-Field systems with default values when partially defined
- Mobile responsive designs prevent horizontal scrolling
- Excel export handles special characters and large datasets

INTEGRATION POINTS:
1. Header loaded dynamically from header.html
2. SheetJS 0.18.5 for Excel export
3. Mermaid.js 10 for diagram visualization
4. Font Awesome 6.4.0 for icons
5. Google Fonts (Nunito) for typography
6. External TRIZ libraries for specialized calculations
7. Chart.js available but not primary for this tool

PERFORMANCE CONSIDERATIONS:
- Matrix rendering optimized for up to 48x48 cells
- Mermaid diagrams re-render only when data changes
- Event delegation used for efficient matrix cell handling
- Lazy loading of example data to improve initial load time
- Efficient data structures for Function Analysis component management

ERROR HANDLING:
- Comprehensive input validation with user-friendly alerts
- Graceful degradation when external libraries fail to load
- Fallback visualizations when diagram rendering fails
- Conservative error handling in contradiction matrix lookups
- URL parameter validation with informative error messages

URL PARAMETER INTEGRATION:
- Supports comprehensive TRIZ parameter injection
- Special handling for matrix versions and indices
- Physical contradiction algorithm parameters
- Su-Field system parameters with type classification
- Auto-calculation triggers for demonstration purposes
- Parameter validation before processing

EDUCATIONAL VALUE:
- Teaches complete TRIZ methodology from problem definition to solution
- Demonstrates interconnections between different TRIZ tools
- Provides real-world examples for each methodology step
- Visualizes abstract concepts like contradictions and Su-Field models
- Encourages systematic problem-solving approach
- Historical context for TRIZ development and key contributors

================================================================================
TOOL 12: ISHIKAWA (FISHBONE) DIAGRAM GENERATOR
================================================================================

APPLICATION OVERVIEW:
This is a free online Fishbone Cause and Effect (Ishikawa) Diagram generator for root cause analysis.
The tool helps teams brainstorm, categorize, and visualize potential causes of a problem using the 6M categories
(Manpower, Methods, Machines, Materials, Environment, Measurement). It creates an interactive SVG diagram that
can be customized and exported.

KEY COMPONENTS:

1. DATA INPUT SYSTEM:
- Wizard-style tabs: Theory & Info, Data Input, Diagram
- Problem statement input field for defining the main issue
- Six 6M categories with hierarchical cause structure:
  • Main causes (level 1)
  • Sub-causes (level 2)
  • Sub-sub-causes (level 3)
- Dynamic category tabs for organized data entry
- Interactive cause management with add/remove functionality

2. VISUALIZATION SYSTEM:
- Interactive SVG fishbone diagram with drag-and-drop text positioning
- Color-coded categories with consistent visual identity
- Automatic layout with collision avoidance
- Legend showing category-color mapping
- Real-time diagram updates as data changes

3. CALCULATION ENGINE:
- Hierarchical data structure for cause organization
- SVG coordinate calculation for optimal diagram layout
- Text wrapping and positioning algorithms
- Mobile-responsive diagram scaling

4. UI STRUCTURE:
- Three main wizard tabs following consistent Sigma Exacta pattern
- Main action buttons (Load Next Example, Reset All) above tabs
- Category sub-tabs within Data Input for organized cause entry
- Responsive design optimized for mobile and desktop
- Tab navigation with smooth transitions

5. URL PARAMETER SUPPORT:
- problem: Problem statement text
- manpower: Pipe-separated main causes (e.g., Cause1|Cause2|Cause3)
- methods: Pipe-separated main causes
- machines: Pipe-separated main causes
- materials: Pipe-separated main causes
- environment: Pipe-separated main causes
- measurement: Pipe-separated main causes
- example: Example type (manufacturing, healthcare, software)
- auto_calculate: Trigger for automatic diagram generation

HOW TO INTERACT WITH THE JAVASCRIPT:

A. INITIALIZATION:
- The application loads with empty input fields
- Event listeners are set up for tab switching, buttons, form controls
- SVG diagram container initialized
- Global variables: currentData, categoryData, diagramNodes, currentExampleIndex
- External libraries: SheetJS for Excel export, html2canvas for JPG export

B. CORE FUNCTIONS:

1. switchWizardTab(tabId)
   - Switches between main wizard tabs (Theory & Info, Data Input, Diagram)
   - Updates active tab styling and scrolls to top

2. initializeSubTabs()
   - Creates category sub-tab content for all 6M categories
   - Sets up sub-tab navigation event listeners

3. switchSubTab(subtabId)
   - Switches between category sub-tabs within Data Input
   - Updates active sub-tab styling and content visibility

4. createCategoryUI()
   - Initializes the category UI structure
   - Sets up currentData.categories object structure

5. addCauseBlock(categoryKey, causeText, subCauses)
   - Adds a new cause block to the specified category
   - Handles hierarchical cause-subcause structure
   - Updates diagram after addition

6. addSubCauseInput(button)
   - Adds sub-cause input field to a main cause
   - Updates diagram after addition

7. addSubSubCauseInput(button)
   - Adds sub-sub-cause input field to a sub-cause
   - Updates diagram after addition

8. collectDataFromDOM()
   - Collects all cause data from input fields into structured object
   - Returns categories object with hierarchical cause structure

9. generateIshikawa()
   - Main diagram generation function
   - Validates problem statement input
   - Calls drawIshikawa() with collected data

10. drawIshikawa(problem, categories)
    - Creates SVG fishbone diagram using calculated coordinates
    - Handles text wrapping and collision avoidance
    - Implements drag-and-drop functionality for text elements
    - Updates diagramNodes map for drag functionality

11. makeDraggable(element)
    - Implements drag-and-drop functionality for SVG text elements
    - Updates connected lines when elements are moved
    - Maintains hierarchical relationships during dragging

12. updateTreePosition(element, dx, dy)
    - Updates position of element and its children during drag
    - Maintains connection lines between elements

13. loadExample(type)
    - Loads example data (manufacturing, healthcare, or software)
    - Populates all categories with example causes
    - Generates diagram automatically
    - Shows notification after loading

14. resetData(redraw)
    - Clears all input fields and resets currentData
    - Optionally redraws empty diagram

15. exportToExcel()
    - Exports cause data to Excel using SheetJS
    - Creates structured worksheet with problem and hierarchical causes
    - Downloads file as "Ishikawa_Diagram_Data_Sigma_Exacta.xlsx"

16. exportToJpg()
    - Exports diagram to JPG image using html2canvas
    - Handles SVG to canvas conversion
    - Downloads file as "Ishikawa_Diagram_Sigma_Exacta.jpg"

C. DATA FLOW:
1. User enters problem statement → stored in currentData.problem
2. User adds causes to categories → stored in currentData.categories
3. Generate Diagram → collectDataFromDOM() gathers all data
4. drawIshikawa() creates SVG visualization
5. User can drag text elements to adjust layout
6. Export functions create Excel or JPG output

D. UI UPDATES:
- Diagram updates in real-time as causes are added/removed
- Text wrapping adjusts based on available space
- Collision avoidance prevents text overlap
- Mobile-responsive diagram scaling
- Tab switching with smooth animations

E. EXPORT FUNCTIONALITY:
- Excel export includes hierarchical cause structure
- JPG export captures current diagram state
- Both exports include problem statement and timestamp

IMPORTANT ALGORITHMS:

1. FISHBONE DIAGRAM LAYOUT:
- Spine calculation: horizontal line with arrow at problem end
- Category bone placement: diagonal lines at calculated angles
- Cause branch placement: perpendicular lines from category bones
- Sub-cause placement: angled lines from cause branches
- Automatic spacing based on number of causes per category

2. TEXT WRAPPING AND COLLISION AVOIDANCE:
- wrapText() function implements multi-line text with tspan elements
- adjustBranchCollisions() prevents text overlap in branches
- Dynamic positioning based on text length and available space

3. DRAG-AND-DROP MECHANISM:
- SVG element dragging with mouse events
- updateTreePosition() maintains hierarchical relationships
- Line connections update dynamically during drag

4. URL PARAMETER PARSING:
- Pipe-separated cause lists for each category
- Example type parameter for quick example loading
- Auto-calculation trigger for automatic diagram generation

EDGE CASE HANDLING:
- Empty problem statement validation
- Handling of special characters in text inputs
- Mobile-responsive diagram scaling
- Empty category handling in diagram generation
- Large text content wrapping and positioning

INTEGRATION POINTS:
1. Header loaded dynamically from header.html
2. SheetJS 0.18.5 for Excel export
3. html2canvas 1.4.1 for JPG export
4. Font Awesome 6.4.0 for icons
5. Google Fonts (Nunito) for typography

PERFORMANCE CONSIDERATIONS:
- Efficient SVG rendering for complex diagrams
- Event delegation for dynamic cause management
- Optimized collision detection algorithms
- Client-side only processing

ERROR HANDLING:
- Input validation with descriptive alerts
- Graceful handling of empty diagram exports
- Notification system for user feedback
- Fallback for browser compatibility issues

URL PARAMETER INTEGRATION:
- Supports Ishikawa-specific parameter injection
- Special handlers for pipe-separated cause lists
- Example type parameter for quick loading
- Auto-calculation trigger for demonstrations
- Parameter validation before processing

EDUCATIONAL VALUE:
- Teaches Ishikawa diagram methodology and history
- Demonstrates 6M categorization for root cause analysis
- Provides real-world examples across industries
- Visualizes cause-effect relationships
- Encourages systematic problem-solving approach

================================================================================
TOOL 13: KANO MODEL ANALYSIS TOOL
================================================================================

APPLICATION OVERVIEW:
This is a free online interactive Kano Model graph and summary table to analyze customer satisfaction.
The tool helps visually categorize product features into five Kano categories (Attractive, Performance, Must-Be, Indifferent, Reverse, Questionable) based on customer survey responses.
It calculates the Customer Satisfaction Index (CS) and provides a visualization of the Kano graph.

KEY COMPONENTS:

1. DATA INPUT SYSTEM:
- Three wizard tabs: Theory & Info, Input & Edit Features, Results
- Input form for features: description, functional response (If present, customer feels: Like it, Expect it, Neutral, Can live with it, Dislike it), dysfunctional response (If not present, customer feels: same options)
- Dynamic categorization table in Input tab showing features by Kano category with remove buttons
- Example data loading (10 example features) and reset functionality

2. CALCULATION ENGINE:
- Kano categorization based on the Kano evaluation table (using functional and dysfunctional responses)
- Customer Satisfaction Index (CS) calculation:
  • CS+ (Satisfaction Index) = (A + O) / (A + O + M + I)
  • CS- (Dissatisfaction Index) = (O + M) / (A + O + M + I) × (-1)
- Feature categorization into: Attractive, Performance, Must-Be, Indifferent, Reverse, Questionable

3. VISUALIZATION SYSTEM:
- Interactive Kano graph (scatter plot) with theoretical curves for each category
- Chart built with Chart.js, displaying features as points on the Kano graph (Satisfaction vs Fulfillment axes)
- Summary table of features by category (editable in Input tab, read-only in Results tab)
- CS Index display with two cards (CS+ and CS-)

4. UI STRUCTURE:
- Wizard-style tabs: Theory & Info, Input & Edit Features, Results
- Main action buttons (Load Example, Reset All) above tabs
- Responsive design for all device sizes
- Tab navigation buttons between tabs

5. URL PARAMETER SUPPORT:
- tab: Active main tab (tab-theory, tab-input-edit, tab-results)
- auto_calculate: Trigger automatic calculation and switch to Results tab (1 or true)
- feature_input: Feature description text
- functional_select: Functional response value (0-4, corresponding to the five options: 0=Like it, 1=Expect it (Must-be), 2=Neutral, 3=Can live with it, 4=Dislike it)
- dysfunctional_select: Dysfunctional response value (0-4, same mapping as functional)
- Note: The universal Query Handler will map parameters to field IDs by converting to lowercase and replacing underscores with hyphens. For example, 'feature_input' maps to field with id 'featureInput'.

HOW TO INTERACT WITH THE JAVASCRIPT:

A. INITIALIZATION:
- The application loads with empty analyzedFeatures array
- Event listeners are set up for form submission, buttons, etc.
- Chart.js and SheetJS are loaded from CDN
- Global kanoApp object is initialized with methods and state

B. CORE FUNCTIONS:

1. switchWizardTab(tabId)
   - Switches between main wizard tabs
   - Updates active tab styling and content visibility
   - Resizes and updates chart if switching to Results tab

2. addFeatureToList(description, funcAnswer, dysfuncAnswer)
   - Adds a new feature to the analyzedFeatures array
   - Categorizes the feature using the Kano table
   - Updates the UI (chart, tables, CS index)

3. removeFeature(featureName)
   - Removes a specific feature from the analyzedFeatures array
   - Updates the UI

4. removeCategory(categoryName)
   - Removes all features in a specific category
   - Updates the UI

5. resetAnalysis()
   - Clears the analyzedFeatures array after confirmation
   - Updates the UI

6. loadExample()
   - Loads 10 example features with functional and dysfunctional responses
   - Steps through each example with a delay for visual effect
   - Updates the UI and switches to Input & Edit tab

7. calculateCSIndex(featuresByCategory)
   - Calculates CS+ and CS- indices based on category counts
   - Returns formatted values and counts

8. drawChart(featuresByCategory)
   - Creates or updates the Kano chart with theoretical curves and feature points
   - Uses Chart.js with custom logo plugin

9. updateUI()
   - Updates the categorization tables, chart, and CS index display

10. exportAnalysis()
    - Exports the complete analysis to Excel using SheetJS
    - Includes feature list, categorization, CS index, and analysis information

C. DATA FLOW:
1. User adds a feature via the form -> addFeatureToList is called
2. Feature is categorized and added to analyzedFeatures array
3. UI updates: chart, tables, and CS index are refreshed
4. User can remove individual features or entire categories
5. User can load example data or reset all
6. User can export the analysis to Excel

D. UI UPDATES:
- Chart updates with new points and theoretical curves
- Categorization tables update in both Input and Results tabs
- CS index cards update with new values
- Notifications show on actions (add, remove, reset, etc.)
- Tabs switch with smooth animations

E. URL PARAMETER INTEGRATION:
- The universal Query Handler will inject parameters into the form fields.
- After injection, if auto_calculate is set, the tool will automatically calculate and switch to the Results tab.
- Field mapping is based on converting parameter names to lowercase and replacing underscores with hyphens to match field IDs.

Example URL:
https://sigmaexacta.com/kano.html?feature_input=Fast%20Check-in&functional_select=0&dysfunctional_select=4&tab=tab-input-edit&auto_calculate=1

This URL would:
1. Set the feature description to "Fast Check-in"
2. Set functional response to "Like it" (value 0)
3. Set dysfunctional response to "Dislike it" (value 4)
4. Open the Input & Edit Features tab
5. Automatically calculate and display results in the Results tab

F. UI FEEDBACK:
- Notification system for actions (feature added, removed, example loaded, etc.)
- Smooth animations for tab switching and chart updates
- Hover effects on chart points to show feature names

G. ERROR HANDLING:
- Input validation for feature description (non-empty)
- Confirmation dialog for reset action
- Graceful handling of empty analysis in exports

H. EXTENSION POINTS:
- Additional import functionality (from Excel or JSON)
- More example datasets
- Advanced filtering and sorting of features
- Sharing analysis via URL with multiple features (currently only one feature can be loaded via URL)

================================================================================
TOOL 14: DESIGN THINKING FACILITATOR TOOL
================================================================================

APPLICATION OVERVIEW:
This is a free online Design Thinking tool that guides users through the 5-stage human-centered design process: Empathize, Define, Ideate, Prototype, and Test. The tool provides structured input fields for each stage, helping teams document insights, generate ideas, create prototypes, and plan tests. It generates comprehensive reports and supports export to Excel and PDF.

KEY COMPONENTS:

1. DATA INPUT SYSTEM:
- Three main tabs: Start & Info, Design Thinking Tool, Results
- Five sub-tabs within Design Thinking Tool for each stage: Empathize, Define, Ideate, Prototype, Test
- Each sub-tab contains form fields for the corresponding stage
- Auto-expanding textareas for better user experience

2. CALCULATION ENGINE:
- Data collection from all 5 stages
- Generation of a summary report
- Export to Excel with detailed data

3. VISUALIZATION SYSTEM:
- Summary report display in the Results tab
- Infographic flow showing the 5 stages

4. UI STRUCTURE:
- Wizard-style tabs and sub-tabs
- Main action buttons (Load Next Example, Reset All) above tabs
- Responsive design for all device sizes

5. URL PARAMETER SUPPORT:
- Parameters for each form field (see field mapping below)
- tab: Main tab to display (tab-start, tab-tool, tab-report)
- sub_tab: Sub-tab within Design Thinking Tool (sub-tab-emphatize, sub-tab-define, sub-tab-ideate, sub-tab-prototype, sub-tab-test)
- auto_calculate: Trigger automatic report generation (1 or true)

HOW TO INTERACT WITH THE JAVASCRIPT:

A. INITIALIZATION:
- The application loads with empty form fields
- Event listeners are set up for tab switching, buttons, etc.
- SheetJS library is loaded for Excel export

B. CORE FUNCTIONS:

1. switchMainTab(tabId)
   - Switches between main tabs
   - Updates active tab styling

2. switchSubTab(subTabId)
   - Switches between sub-tabs in the Design Thinking Tool
   - Updates active sub-tab styling

3. loadNextExample()
   - Cycles through example datasets (coffee, healthcare, education)
   - Populates all form fields with example data
   - Switches to the Design Thinking Tool tab and first sub-tab

4. resetTool()
   - Resets all form fields and hides the results

5. generateReport()
   - Validates the form and generates a summary report
   - Displays the report in the Results tab

6. exportToExcel()
   - Exports the complete Design Thinking data to an Excel file

7. exportToPDF()
   - Triggers browser's print function for PDF export

8. copyToClipboard()
   - Copies the report summary to clipboard

C. DATA FLOW:
1. User enters data in the Design Thinking Tool sub-tabs
2. Generate Report collects the data and displays a summary
3. Export functions create Excel, PDF, or clipboard output

D. UI UPDATES:
- Tabs and sub-tabs switch with smooth animations
- Textareas auto-expand based on content
- Report section becomes visible after generation

E. URL PARAMETER INTEGRATION:
- The Query Handler will inject parameters into the corresponding form fields.
- Field mapping: Parameter names are derived from the field IDs by converting to lowercase and replacing hyphens with underscores. For example, 'empathize-users' becomes 'empathize_users'.
- Special parameters:
  - 'tab' sets the active main tab.
  - 'sub_tab' sets the active sub-tab within the Design Thinking Tool.
  - 'auto_calculate' triggers the report generation automatically.

Example URL:
https://sigmaexacta.com/design_thinking.html?empathize_users=Busy%20commuters&define_pov=User%20needs%20coffee&tab=tab-tool&sub_tab=sub-tab-define&auto_calculate=1

This URL would:
1. Set empathize users to "Busy commuters"
2. Set define point of view to "User needs coffee"
3. Open the Design Thinking Tool tab
4. Open the Define sub-tab
5. Automatically generate the report

F. UI FEEDBACK:
- Notification system for actions (load example, reset, export)
- Smooth scrolling when switching tabs

G. ERROR HANDLING:
- Form validation before generating report
- Confirmation dialog for reset

H. EXTENSION POINTS:
- Additional example datasets
- Integration with other tools (e.g., SWOT, Business Model Canvas)
- Collaborative features for team workshops

================================================================================
TOOL 15: EISENHOWER MATRIX (URGENT-IMPORTANT MATRIX)
================================================================================

APPLICATION OVERVIEW:
This is an interactive Eisenhower Matrix tool for task prioritization. It helps users categorize tasks into four quadrants based on urgency and importance: Do (Urgent & Important), Decide (Not Urgent & Important), Delegate (Urgent & Not Important), and Delete (Not Urgent & Not Important). Users can add, remove, and drag tasks between quadrants, and export the matrix to Excel.

KEY COMPONENTS:

1. DATA INPUT SYSTEM:
- Three main tabs: Theory & Info, Build & Edit, Results
- Form for adding tasks: task description and quadrant selection
- Four quadrants display tasks with delete buttons
- Example data loading for demonstration

2. CALCULATION ENGINE:
- Task management: add, delete, and list tasks
- Results listing for export

3. VISUALIZATION SYSTEM:
- Four-quadrant matrix with color coding
- Task lists in each quadrant

4. UI STRUCTURE:
- Wizard-style tabs
- Main action buttons (Load Example, Reset All) above tabs
- Responsive design for all device sizes

5. URL PARAMETER SUPPORT:
- Parameters for form fields (taskInput, quadrantSelect)
- tab: Main tab to display (tab-theory, tab-build-edit, tab-results)
- auto_calculate: Trigger automatic results listing (1 or true)

HOW TO INTERACT WITH THE JAVASCRIPT:

A. INITIALIZATION:
- The application loads with empty task list
- Event listeners are set up for form submission, buttons, etc.
- SheetJS library is loaded for Excel export

B. CORE FUNCTIONS:

1. switchWizardTab(tabId)
   - Switches between main tabs
   - Updates active tab styling

2. addTaskToQuadrant(description, quadrantId)
   - Adds a new task to the specified quadrant
   - Updates the task list array

3. addTaskFromForm()
   - Gets task description and quadrant from form and adds task

4. resetMatrix()
   - Clears all tasks from all quadrants

5. displayResults()
   - Lists tasks in the Results tab for export

6. exportToExcel()
   - Exports the matrix tasks to an Excel file

C. DATA FLOW:
1. User adds tasks via form
2. Tasks are stored in an array and displayed in quadrants
3. List Results displays tasks in Results tab
4. Export creates Excel file with tasks by quadrant

D. UI UPDATES:
- Tasks appear in quadrants with delete buttons
- Results tab shows read-only matrix
- Notifications for user actions

E. URL PARAMETER INTEGRATION:
- The Query Handler will inject parameters into the form fields.
- Field mapping: Parameter names are derived from field IDs. 'taskInput' becomes 'task_input', 'quadrantSelect' becomes 'quadrant_select'.
- Special parameters:
  - 'tab' sets the active main tab.
  - 'auto_calculate' triggers the results listing automatically.

Example URL:
https://sigmaexacta.com/eisenhower.html?task_input=Finish%20report&quadrant_select=quadrant-do&tab=tab-build-edit&auto_calculate=1

This URL would:
1. Set task description to "Finish report"
2. Set quadrant to "Do (Urgent & Important)"
3. Open the Build & Edit tab
4. Automatically list results

F. UI FEEDBACK:
- Notification system for actions (add task, reset, export)
- Smooth tab switching

G. ERROR HANDLING:
- Confirmation dialog for reset
- Validation for empty task description

H. EXTENSION POINTS:
- Drag-and-drop between quadrants
- Due dates and priorities for tasks
- Integration with calendar tools

================================================================================
TOOL 16: APQP/PPAP PLANNING TOOL
================================================================================

APPLICATION OVERVIEW:
This is a dynamic APQP (Advanced Product Quality Planning) and PPAP (Production Part Approval Process) planning tool that helps manage new product development projects according to industry standards. It allows users to track phases, tasks, and PPAP elements, generate Gantt charts, and export reports. It is designed for quality engineers and project managers.

KEY COMPONENTS:

1. DATA INPUT SYSTEM:
- Project setup with basic information (project name, part number, customer, lead, team members)
- Five APQP phases (Plan & Define, Product Design, Process Design, Validation, Feedback) with dynamic task management
- PPAP checklist with 18 standard elements
- Interactive forms for adding, editing, and deleting tasks and elements

2. CALCULATION ENGINE:
- Automatic generation of Gantt charts based on task dates
- Automatic action plan generation from pending and in-progress tasks
- Status tracking for tasks and PPAP elements

3. VISUALIZATION SYSTEM:
- Gantt chart visualization for project timeline
- Color-coded status indicators for tasks (pending, in progress, completed, N/A)
- Action plan table for tracking open items

4. UI STRUCTURE:
- Wizard-style tabs: Theory & Info, Project Setup, Gantt, Action Plan
- Subtabs within Project Setup for each APQP phase and PPAP checklist
- Responsive design for all device sizes

5. URL PARAMETER SUPPORT:
- tab: Main tab to display (tab-theory, tab-project-setup, tab-gantt, tab-action-plan)
- sub_tab: Sub-tab within Project Setup (subtab-project-config, subtab-phase1, subtab-phase2, subtab-phase3, subtab-phase4, subtab-phase5, subtab-ppap)
- auto_calculate: Trigger automatic Gantt generation or action plan generation (1 or true)
- Note: The universal Query Handler can inject values into form fields based on field IDs.

HOW TO INTERACT WITH THE JAVASCRIPT:

A. INITIALIZATION:
- The application loads with empty project data or example data
- Event listeners are set up for form inputs, buttons, and tab navigation

B. CORE FUNCTIONS:

1. switchMainTab(tabId)
   - Switches between main tabs (Theory & Info, Project Setup, Gantt, Action Plan)
   - Updates active tab styling and content visibility

2. switchSubTab(subTabId)
   - Switches between subtabs within the Project Setup tab (for each APQP phase and PPAP checklist)
   - Updates active subtab styling and content visibility

3. renderProjectSetup()
   - Renders the project setup form with current project information

4. renderApqpPhases()
   - Renders the task tables for each APQP phase

5. renderPpapChecklist()
   - Renders the PPAP checklist table

6. loadExample()
   - Loads example project data with tasks and PPAP elements
   - Switches to the Project Setup tab and first subtab

7. resetForm()
   - Resets all project data to initial state

8. generateGantt()
   - Generates a Gantt chart based on task start and end dates

9. generateActionItems()
   - Generates an action plan table with pending and in-progress tasks from APQP and PPAP

10. exportGanttToExcel(), exportGanttToImage(), exportActionPlanToExcel()
    - Export functionality for Gantt chart and action plan

C. DATA FLOW:
1. User enters project information and team members
2. User adds tasks to each APQP phase and updates PPAP checklist
3. User generates Gantt chart to visualize timeline
4. User generates action plan to track open items
5. User can export data to Excel or images

D. UI UPDATES:
- Dynamic table updates as tasks are added or removed
- Gantt chart updates with task bars and timeline
- Action plan table updates with current open items
- Tab and subtab switching with smooth animations

E. URL PARAMETER INTEGRATION:
- The Query Handler will inject parameters into the corresponding form fields.
- Field mapping: Parameter names are derived from the field IDs by converting to lowercase and replacing hyphens with underscores.
- Special parameters:
  - 'tab' sets the active main tab.
  - 'sub_tab' sets the active sub-tab within the Project Setup tab.
  - 'auto_calculate' triggers the Gantt generation or action plan generation automatically.

F. UI FEEDBACK:
- Notifications for actions (load example, reset, etc.)
- Visual feedback for task status (color coding)

G. ERROR HANDLING:
- Confirmation dialog for reset action
- Validation for task dates

H. EXTENSION POINTS:
- Additional export formats (PDF, etc.)
- Integration with project management tools
- Advanced reporting features

================================================================================
TOOL 17: STRATEGIC PERFORMANCE SCORECARD (BALANCED SCORECARD)
================================================================================

APPLICATION OVERVIEW:
This is an interactive Strategic Performance Scorecard tool, inspired by the Balanced Scorecard framework. It helps organizations track performance across four perspectives: Financial, Customer, Internal Processes, and Learning & Growth. Users can define objectives, KPIs, targets, and initiatives, and monitor performance with visual indicators.

KEY COMPONENTS:

1. DATA INPUT SYSTEM:
- Form for adding metrics with perspective, objective, measure (KPI), target, actual value, and initiative
- Dynamic dropdowns for objectives and measures based on selected perspective
- Option to enter custom objectives and measures
- Four tables (one per perspective) for displaying metrics

2. CALCULATION ENGINE:
- Automatic calculation of performance percentage (actual vs target)
- Performance categorization (Good, Average, Poor) based on achievement
- Summary progress bars for each perspective

3. VISUALIZATION SYSTEM:
- Progress bars for each perspective showing average performance
- Color-coded badges for each metric (green, yellow, red)
- Results table for consolidated view

4. UI STRUCTURE:
- Wizard-style tabs: Theory & Info, Scorecard Builder, Results
- Responsive design for all device sizes

5. URL PARAMETER SUPPORT:
- tab: Main tab to display (tab-theory, tab-builder, tab-results)
- auto_calculate: Trigger automatic results listing (1 or true)
- perspective: Selected perspective (financial, customer, internal, learning)
- objective: Objective text or selection
- measure: Measure (KPI) text or selection
- target: Target value
- actual: Actual value
- initiative: Strategic initiative text
- Note: The universal Query Handler will map parameters to field IDs by converting to lowercase and replacing underscores with hyphens.

HOW TO INTERACT WITH THE JAVASCRIPT:

A. INITIALIZATION:
- The application loads with empty tables and form
- Event listeners are set up for form inputs, buttons, and tab navigation

B. CORE FUNCTIONS:

1. switchWizardTab(tabId)
   - Switches between main tabs (Theory & Info, Scorecard Builder, Results)
   - Updates active tab styling and content visibility

2. updateObjectiveDropdown()
   - Updates the objective dropdown based on selected perspective

3. updateMeasureDropdown()
   - Updates the measure dropdown based on selected perspective and objective

4. validateForm()
   - Validates form inputs and enables/disables the add button

5. addEntryToTable()
   - Adds a new metric to the corresponding perspective table
   - Calculates performance and updates summaries

6. updateSummaries()
   - Updates the progress bars for each perspective based on current metrics

7. loadExample()
   - Loads example metrics across all perspectives

8. resetAll()
   - Resets all metrics and form

9. listResults()
   - Generates a read-only results view in the Results tab

10. exportToExcel()
    - Exports all metrics to an Excel file with separate sheets per perspective

C. DATA FLOW:
1. User selects perspective, objective, and measure (or enters custom)
2. User enters target, actual value, and initiative
3. Metric is added to the table with calculated performance
4. Progress bars update automatically
5. User can view results and export data

D. UI UPDATES:
- Dynamic table updates as metrics are added or deleted
- Progress bars update in real-time
- Results view updates when generated
- Toast notifications for user actions

E. URL PARAMETER INTEGRATION:
- The Query Handler will inject parameters into the corresponding form fields.
- Field mapping: Parameter names are derived from field IDs by converting to lowercase and replacing underscores with hyphens.
- Special parameters:
  - 'tab' sets the active main tab.
  - 'auto_calculate' triggers the results listing automatically.

F. UI FEEDBACK:
- Toast notifications for actions (add, delete, reset, etc.)
- Visual feedback for performance (badges and progress bars)

G. ERROR HANDLING:
- Form validation with required fields
- Confirmation dialog for delete actions

H. EXTENSION POINTS:
- Additional perspectives or custom perspectives
- Historical tracking and trend analysis
- Integration with data sources for automatic KPI updates

================================================================================
COMMON FEATURES ACROSS ALL TOOLS:

1. UI ARCHITECTURE:
- Wizard-style tab navigation
- Responsive design for all devices
- Consistent styling and color scheme
- Header/footer consistency
- Main action buttons (Load Example, Reset All) above tabs

2. DATA MANAGEMENT:
- Client-side only processing
- No server communication
- Excel export functionality
- Example data loading
- Global data objects for tool state management

3. EDUCATIONAL VALUE:
- Theoretical explanations in Theory tabs
- Step-by-step instructions
- Real-world application examples
- Best practices guidance
- Historical context and methodology origins

4. ERROR HANDLING:
- Input validation with descriptive messages
- Informative error messages
- Graceful degradation for missing features
- Fallback mechanisms for partial data
- Confirmation dialogs for destructive actions

5. URL PARAMETER SUPPORT:
- Universal Query Handler for all tools
- Automated data injection from URL parameters
- Auto-calculation triggering
- Field mapping intelligence
- Special handlers for tool-specific parameters
- Parameter validation and error handling

TESTING RECOMMENDATIONS FOR ALL TOOLS:
- Test with example data provided
- Test export functionality
- Test responsive design on different devices
- Test edge cases (empty inputs, large datasets)
- Verify calculations against known standards
- Test URL parameter functionality with various parameter combinations
- Test tab navigation and state persistence
- Test mobile interactions and touch events

SECURITY NOTES FOR ALL TOOLS:
- All calculations occur client-side
- No data sent to servers
- Input sanitization for data export
- URL parameter validation to prevent injection attacks
- No persistent storage of sensitive data
- All libraries loaded from trusted CDNs

MAINTENANCE FOR ALL TOOLS:
- Keep external libraries updated
- Monitor for browser compatibility issues
- Regular testing of calculation accuracy
- Update example data as needed
- Maintain URL parameter compatibility when updating tools
- Document new features and changes
- Monitor performance on mobile devices

EXTENSION POINTS FOR ALL TOOLS:
1. Additional import functionality (from Excel)
2. Cloud saving/loading of plans
3. Additional predefined options
4. Custom template creation
5. Collaboration features
6. Advanced filtering and sorting
7. Report generation in multiple formats
8. Enhanced URL parameter support for more tools
9. API integration for external data sources
10. Batch processing capabilities
11. Multi-language support
12. Accessibility enhancements
13. Offline functionality
14. Advanced visualization options
15. Integration with other quality tools

Information provided by http://SigmaExacta.com